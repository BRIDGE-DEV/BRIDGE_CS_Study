## CPU 가상화
* 여러 작업들이 동시에 실행되는 것처럼 보이도록 물리적인 CPU 공유
* **시분할(Time Sharing) 방법 사용**
  * CPU를 짧은 단위로 쪼개어 각 프로세스에게 번갈아가며 CPU 할당
* **운영체제가 직면하는 두가지 문제**
  1. 성능 저하 (Performance) : 프로세스를 너무 자주 교체하면 오버헤드 발생
  2. 제어 문제 (Control) : 운영체제가 CPU의 통제를 유지해야 함
* **제어권을 유지하며 성능 저하가 없도록 하는 것**이 핵심적 도전 과제

## 제한적 직접 실행 (LDE; Limited Direct Execution)
### 직접 실행
* 운영제체가 프로그램을 CPU에서 직접 실행함, 빠르게 실행됨
* **일반적인 실행 흐름**
  1. 프로세스 목록의 항목을 생성
  2. 프로그램 메모리 할당
  3. 메모리에 프로그램 탑재
  4. argc/argv를 위한 스택 셋업
  5. 레지스터 내용 삭제
  6. call main() 실행
  7. main() 실행
  8. main()에서 return 명령어 실행
  9. 프로세스 메모리 반환
  10. 프로세스 목록에서 항목 제거
* **직접 실행의 문제점**
  1. 제어 불가능 (Control) 문제
     * CPU에서 직접 실행 시 운영체제가 제한 없이 실행되도록 허용하는 셈
     * 자원 독점 및 보안 위협 가능
  2. 시분할 (Time Sharing) 불가 문제
     * 다른 프로세스를 실행하려면 현재 프로세스의 실행을 중단해야 함
     * 프로세스가 CPU를 계속 점유한다면 운영체제가 끼어들 수 없음

### 문제점 1 : 제한된 연산 (Restricted Operations)
* 직접 실행의 문제
  * 사용자 프로그램이 특수 연산을 직접 수행할 수 있다면 보안과 안정성 문제 발생
    * 특수 연산 : 디스크 I/O, 시스템 자원(CPU, 메모리)에 대한 추가 할당 요청
  * 커널의 코드 영역이나 다른 프로세스의 메모리에 접근 가능
* **이중 모드 (Dual Mode)**
  * 사용자 모드 (User Mode)
    * 일반 사용자 프로세스 실행
    * 권한 제한됨 (I/O 등 불가)
    * 시스템 콜 또는 인터럽트 발생 시 전환
  * 커널 모드 (Kernel Mode)
    * 운영체제 핵심 기능 실행
    * 모든 명령어 실행 가능
    * 작업 완료 후 사용자 모드로 복귀
  * 사용자 모드에서 특수 명령어 실행 시 예외(Exception) 발생, OS가 해당 프로세스 제거 가능
* **시스템 콜 (System Call)**
  * 사용자 프로그램이 제한된 작업을 수행할 수 있도록 운영체제에게 요청하는 인터페이스
  * 커널은 시스템 콜을 통해 자신의 주요 기능을 사용자 프로그램에게 제공
    * 파일 시스템 접근, 프로세스 생성 및 제거, 다른 프로세스와의 통신 및 메모리 할당 등
  * 일종의 소프트웨어적 인터럽트
  * CPU가 시스템 콜을 처리하는 순서는 인터럽트 처리 순서와 유사
  * **시스템 콜 실행 절차**
    * 사용자 프로세스가 trap 명령어 실행
      * trap 명령어 : 커널 안으로 분기 및 특권 수준을 커널 모드로 상향 조정
    * 하드웨어가 커널 모드로 전환하고 트랩 핸들러로 분기
    * 운영체제가 요청을 처리
    * return-from-trap 명령어로 다시 사용자 모드로 하향 조정
  * trap 명령어의 주의점
    * return-from-trap 명령어 실행 시 사용자 프로세스로 제대로 리턴해야 함
    * 따라서 호출한 프로세스의 필요한 레지스터들을 커널 스택에 저장
      * 프로그램 카운터, 플래그 레지스터 등
    * return-from-trap 명령어 실행 시 커널 스택에서 pop하며 복귀
* **트랩 테이블 (Trap Table)**
  * 트랩이 실행될 때 분기하는 위치
    * 운영체제가 trap을 호출한다고 해서 아무 코드나 실행되면 안 됨
    * 호출한 프로세서는 분기할 주소 명시 불가
    * 운영체제는 트랩 테이블을 미리 설정
  * 트랩 테이블의 동작
    * 부팅 시 커널이 트랩 테이블을 초기화
    * 하드웨어에 테이블 위치 등록 (특권 명령어 사용)
    * 운영체제는 특권 명령어를 사용해 하드웨어에게 트랩 핸들러의 위치 제공
    * 시스템 콜은 시스템 핸들러로 정해진 위치로만 분기
  * 주소 등록 또한 사용자 모드에서는 불가능

* LDE 프로토콜의 흐름
  1. 부팅
     * 커널 모드로 부팅
     * 트랩 테이블 생성 및 등록 (Trap Handler 정보 포함)
     * CPU는 나중에 사용하기 위해 테이블의 위치 기억
  2. 사용자 프로그램 실행
     * 운영체제가 return-from-trap 명령어로 사용자 모드 전환 및 실행
     * 실행 중 시스템 콜 발생 (Trap 실행)
     * 커널 모드 진입, 시스템 콜 처리
     * 다시 return-from-trap으로 사용자 모드 복귀
  3. 종료
     * exit() 시스템 콜로 종료 요청, 다시 trap
     * 운영체제가 프로세스를 정리

### 문제점 2 : 프로세스 간 전환 (Context Switching)
**직접 실행 방식에서는 사용자 프로세스가 CPU에서 실행 중일 때 운영체제는 실행되지 않음
OS가 CPU를 갖고 있지 않으면 다른 프로세스로 전환할 수 없음
운영체제가 CPU 제어권을 언제, 어떻게 확보하느냐**

* **협조 방식 (Cooperative)**
  * 과거의 운영체제들(초기 Mac OS, Xerox Alto)은 프로세스가 자발적으로 OS에게 CPU를 넘겨줄 것이라 신뢰
    * 너무 오래 실행되지 않도록 직접 yield() 시스템 콜을 호출
    * I/O 요청 등 시스템 콜을 통해 OS에게 제어권을 넘겨주는 것에 의존
  * read(), write(), send(), fork() 등의 시스템 콜을 하면 자동으로 OS에게 제어권 이동
  * 프로세스가 비정상적인 행위를 할 경우에도 OS에게 제어권 이동
    * 수를 0으로 나누는 연산 등, 트랩 발생
  * yield()를 명시적으로 호출해 다른 프로세스 실행 허용
  * **단점**
    * 버그 또는 악의적 행위로 시스템 콜을 호출하지 못할 경우 (무한 루프)
    * 리부팅 외에는 방법이 없음
* **비협조 방식 (Preemptive)**
  * 현대 운영체제는 하드웨어의 지원, 타이머 인터럽트 이용
  * 운영체제가 일정 시간마다 CPU 제어권을 자동으로 되찾음
  * **타이머 인터럽트**
    * CPU가 몇 밀리초마다 발생시키는 인터럽트
    * 발생 시 현재 실행중인 프로세스 중단, 운영체제 활성화, 스케줄링/컨텍스트 스위칭/기타 작업 수행
  * 간단한 동작 흐름
    * 부팅 시 OS가 타이머 인터럽트 핸들러 주소를 하드웨어에 등록
    * CPU는 일정 주기로 타이머 인터럽트 발생
    * 운영체제 코드 실행
      * 미리 구성된 인터럽트 핸들러 (Interrupt Handler) 실행
    * OS는 실행중이던 프로세스의 상태를 커널 스택에 저장
    * 다른 프로세스를 선택, 실행
    * return-from-trap 명령어로 선택한 프로세스 재시작
  * 위의 방식으로 프로세스가 무한 루프에 빠져도 OS 개입 가능
  * 선점형 스케줄링(Preemptive Scheduling) 구현에 필요
* **문맥의 저장과 복원**
  * 시스템 콜이나 타이머 인터럽트를 통해 CPU 제어권을 획득하면 프로세스를 계속 실행할지 다른 프로세스로 전환할 것인지 선택해야 함
  * 이 결정은 스케줄러(Scheduler)에 의해 이루어짐
  * **문맥 교환 (Context Switching)**
    * 운영체제가 다른 프로세스로 전환하기로 결정하면 문맥 교환 과정 수행
    * 현재 프로세스의 레지스터 상태 등을 저장하고 다음 실행할 프로세스의 상태를 복원하는 과정
    * return-from-trap 명령어가 이전 프로세스가 아닌 다른 프로세스로 돌아가도록 만듦
  * 문맥 교환의 과정
    * 현재 실행 중인 프로세스의 범용 레지스터, 프로그램 카운터, 커널 스택 포인터가 프로세스의 커널 스택 또는 구조체에 저장
    * 다음 실행할 프로세스의 레지스터, 프로그램 카운터, 커널 스택 포인터를 해당 구조체에서 복원
    * 스택 포인터도 새로운 프로세스의 커널 스택을 가리키도록 변경
    * return-from-trap 명령어 실행, 복원된 프로세스가 CPU를 이어받아 실행 시작
  * 레지스터 저장 및 복원은 두 번 발생
    * 인터럽트 발생 시 실행 중인 프로세스의 사용자 레지스터가 하드웨어에 의해 해당 프로세스의 커널 스택에 암묵적으로 저장
    * 프로세스 전환 시 커널 레지스터라는 운영체제에 의해 해당 프로세스의 프로세스 구조체제 저장
  * 문맥 교환의 작업 시간
    * 프로세서의 성능 개선 추이와 비슷하게 점점 발전
    * 1996년의 시스템 콜 작업 시간 : 4 마이크로초
    * 1996년의 문맥 교환 작업 시간 : 6 마이크로초
    * 현대에는 1 마이크로초 미만 소요
    * 운영체제의 모든 동작이 CPU 성능에 따라 좋아지는 것이 아님
      * 운영체제의 많은 연산은 주로 메모리 접근 연산
      * 메모리의 대역폭은 프로세서 속도가 발전하는 것 만큼 극적 향상이 아님

***
_출처 : OSTEP (Operating Systems : Three Easy Pieces)_
