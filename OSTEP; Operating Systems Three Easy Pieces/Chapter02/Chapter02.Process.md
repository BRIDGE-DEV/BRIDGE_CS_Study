## 프로세스란?
**프로세스 : 실행 중인 프로그램
프로그램은 디스크 상의 명령어, 데이터 묶음
운영체제가 이 묶음을 실행함으로써 프로세스에 생명 부여**

### CPU 가상화
* 사용자는 프로그램이 동시에 실행되길 원함
* 운영체제는 CPU 하나로 여러 프로세스를 실행하는 환상 제공
* **시분할 (Time Sharing)**
  * 하나의 프로세스를 일정 시간 실행 후 중단
  * 다음 프로세스 실행
  * 위의 과정을 반복해 동시에 실행되는 것처럼 보이게 함
  * CPU를 공유하기 때문에 각 프로세스의 성능은 저하
* CPU 가상화를 위한 두 구성 요소
  * **메커니즘 (Mechanism)** : 동작을 실제로 구현하는 저수준 도구
    * ex) 문맥 교환 (Context Switching)
    * 필요한 기능을 구현하는 방법이나 규칙
  * **정책 (Policy)** : 결정을 내리는 고수준의 전략 (알고리즘)
    * ex) 스케줄링 정책 (Scheduling Policy)
    * 판단 기준 : 과거 실행 정보, 워크로드 특성, 성능 측정 결과 등
* 시분할과 대응되는 개념 : 공간 분할 (Space Sharing)
  * 개체에게 공간을 분할 (ex. 디스크)

### 프로세스를 구성하는 주요 요소
* **메모리 (Address Space)**
  * 프로그램의 명령어와 데이터가 저장된 공간
  * 프로세스가 접근 가능한 메모리 전체를 가리킴
* **레지스터 (Registers)**
  * 프로그램 실행 중 지속적으로 읽고 쓰이는 소형 저장 공간
  * 프로세스 실행에 필수적
  * 프로그램 카운터 (PC; Program Counter / IR) : 현재 실행 중인 명령어의 위치
  * 스택 포인터 (SP) : 함수 호출 시 지역 변수 및 리턴 주소 저장
  * 프레임 포인터 (FP) : 현재 함수의 스택 프레임 기준점
* **영구 저장장치 (Persistent Storage)**
  * 프로세스가 열어둔 파일 목록
  * 디스크, 네트워크 등과 상호작용하기 위해 필요

### 프로세스 API
* 프로세스를 생성하고 제어할 수 있는 기본 API 제공
* 모든 현대 운영체제에서 제공
* 생성 (Create)
  * 새로운 프로세스 생성
  * ex) 응용 프로그램 아이콘 더블 클릭, 쉘에 명령어 입력
* 제거 (Destroy)
  * 불필요하거나 오류가 있는 프로세스 종료
  * 자발적으로 종료되지 않는 경우 강제 종료 가능
* 대기 (Wait)
  * 다른 프로세스가 종료되길 기다리는 기능
  * 프로세스간 동기화에 사용
* 각종 제어 (Miscellaneous Control)
  * 프로세스 일시정지 또는 재개 등의 제어 기능 제공
* 상태 조회 (Status)
  * 프로세스의 현재 상태나 실행 시간 등의 정보 조회

### 프로세스 생성
* 프로그램 코드와 정적 데이터 메모리 탑제
  * 프로그램은 디스크나 SSD에 실행 파일 형식으로 저장
  * 실행 시, 코드와 정적 데이터를 프로세스의 주소 공간에 탑재
  * 초기 운영체제는 모든 코드와 데이터를 한 번에 메모리에 탑재
  * 현대 운영체제는 필요할 때 부분적으로 탑재 (페이징, 스와핑, 요구 페이징)
* 실행 시간 스택 (Run-Time Stack,  스택) 할당
  * 지역 변수, 함수 인자, 리턴 주소 등을 저장
  * 스택을 생성, main() 함수 실행을 위해 argc, arvc 값으로 초기화
* 힙 메모리 영역 할당
  * 동적 메모리 할당을 위한 공간
  * C언어의 malloc(), free() 호출에 대응
  * 가변 크기 자료구조(연결 리스트, 해시 테이블 등)를 위해 사용
* 입출력 관련 초기화
  * UNIX 시스템 기준, 기본 파일 디스크립터 3개 설정
  * STDIN(표준 입력), STDOUT(표준 출력), STDERR(표준 에러)
  * 이를 통해 터미널과 쉽게 입출력 가능
* 프로그램 시작 지점으로 분기
  * 모든 초기화 완료 후, 프로그램의 entry point로 분기 (main())
  * 이 지점부터 CPU를 프로세스에 넘기고 실행 시작

### 프로세스 상태
* 기본 프로세스 상태
  * 실행 (Running) : 프로세서에서 실제로 명령어를 실행 중인 상태
  * 준비 (Ready) : 실행 준비 완료, 아직 CPU를 할당받지 못함
  * 대기 (Blocked) : 입출력 등의 이벤트 완료를 기다리는 상태
* 상태 전이
  * Ready => Running : CPU에 스케줄링 되면 전이
  * Running => Ready : CPU를 선점(Preempt) 당하거나 스케줄링 정책에 의해 양보
  * Running => Blocked : 입출력 요청 등 외부 이벤트 발생
  * Blocked => Ready : 이벤트 완료, 실행 준비 완료
* 상태 전이 예시
  * 두 프로세스가 모두 CPU만 사용
    * 둘 다 I/O 요청 없이 실행
    * Process0이 먼저 실행 후 Process1 실행
  * Process0이 IO 요청
    * Process0 실행 중 I/O 요청시 Blocked 전이
    * Process1 실행 후 Process0의 I/O 완료 시 Ready로 복귀 후 실행
* 스케줄링 결정
  * 여러 상황에서 결정을 내려야 함
  * 이러한 결정은 스케줄러(Scheduler)라는 구성 요소가 담당

### 자료구조
* 다양한 프로세스를 추적, 관리하기 위해 자료구조 사용
* 주요 자료구조
  * 프로세스 리스트 (Process List) : 현재 존재하는 모든 프로세스 정보를 담고 있는 리스트
  * 준비 큐 (Ready Queue) : 준비 상태에 있는 프로세스 목록
  * 대기 큐 (Blocked Queue) : 입출력 등 이벤트를 대기중인 프로세스  목록
  * 실행 프로세스 정보 : 현재 CPU에서 실행 중인 프로세스에 대한 정보
* **프로세스 제어 블록 (PCB; Process Control Block)**
  * 각 프로세스를 추적하기 위해 유지하는 정보들을 담는 자료구조
  * xv6같은 운영체제에서 프로세스 정보는 struct proc에 저장
  * 레지스터 문맥 (Register Context)
    * 프로세스가 CPU에서 중단될때 레지스터 값들을 저장해두는 구조
    * 다시 실행할 때 이 값을 복원하여 재개
    * 이를 문맥 교환 (Context Switching)
* 기타 프로세스 상태
  * 초기 상태 (Initial) : 프로세스가 생성 중일 때 일시적으로 머무름
  * 최종 상태 (Final or Zombie) : 프로세스가 종료되었지만 자식 종료 여부를 확인할 때까지 메모리에 남아 있는 상태

***
## PCB 내부 정보
* 프로세스 ID (PID) : 프로세스를 식별하기 위해 부여하는 고유 번호
* 레지스터 값 : 이전까지의 작업을 이어 실행할 수 있도록 실행하며 사용했던 레지스터 값
* 프로세스 상태 : 현재 프로세스의 상태 (Ready, Running 등)
* CPU 스케줄링 정보 : 언제 CPU에 할당 받을 수 있을지에 대한 정보 (우선 순위, 실행 시각 등)
* 메모리 관리 정보 : 어느 주소에 저장된 지에 대한 정보 (페이지 테이블 정보 등)
* 사용한 파일 및 입출력 장치 목록 : 실행 과정에서 파일이나 입출력 장치 사용 시 해당 내용 명시

## 문맥 교환 비용 (Context Switching Overhead)
* 문맥 교환 비용이 발생하는 원인
  * 레지스터 저장 및 복원
    * CPU가 현재 사용 중인 레지스터 값을 PCB에 저장
    * 다음 프로세스의 PCB에서 레지스터 값을 읽어와 복원
  * 캐시 무효화 (Cache Invalidation)
    * CPU 캐시에는 이전 프로세스의 데이터 저장
    * 새 프로세스는 다른 데이터를 요구, 캐시 미스(Cache Miss) 증가
    * 성능 하락의 핵심 원인
  * TLB(Translation Lookaside Buffer) 플래시
    * TLB는 가상 주소와 물리 주소 매핑을 캐싱
    * 문맥 교환 시 보안을 위해 TLB를 지움 (TLB 플래시)
    * 페이지 테이블 재탐색 필요, 메모리 접근 지연
  * 커널 모드와 사용자 모드 전환
    * 문맥 교환은 일반적으로 커널 모드에서 수행
    * 권한 전환 발생, 시스템 콜 처리 비용
  * 스케줄링 결정 비용
    * 어떤 프로세스를 다음으로 실행할지 결정하는 데에 연산 필요
    * 스케줄링 알고리즘에 따라 비용 차이 존재
* 미치는 영향
  * 수백~수천 나노초(ns) 정도의 시간 필요
  * 하드웨어와 운영체제, 캐시 상태, 메모리 계층에 따라 달라짐
  * 특히 CPU 캐시 미스나 TLB 플러시는 문맥 교환 이후에도 지속적인 성능 저하 유발
* 결론
  * 문맥 교환이 자주 일어나면 성능은 급격히 하락
  ex) 많은 스레드나 프로세스를 동시 실행
  * 따라서 OS는 문맥 교환을 최대한 줄이는 방향으로 설계

## 가상메모리(Paging, Swapping)와 지연 로딩
* 가상 메모리(Virtual Memory)
  * 가상 메모리는 실제 메모리보다 더 큰 주소 공간을 사용하는 개념
  * 프로그램은 자신만의 연속적인 메모리 주소를 갖는다 착각, 운영체제는 실제로 필요한 데이터만 물리 메모리에 적재
  * 주 목적
    * 메모리 부족 문제 해결
    * 프로세스 간 메모리 보호
    * 효율적 메모리 사용
* 페이징(Paging)
  * 가상 메모리 공간을 고정 크기 단위(페이지, Page)로 분할
  * 물리 메모리도 페이지와 같은 크기의 프레임(Frame)으로 분할
  * 가상 주소에서 물리 주소 매핑은 페이지 테이블(Page Table)을 통해 수행
  * 모든 페이지를 처음부터 물리 메모리에 적재하지 않음
    * 필요한 순간에 올리는 방식 : 지연 로딩 (Lazy Loading)
* 스와핑(Swaping)
  * 물리 메모리가 부족할 때, 일부 페이지를 디스크로 내보내는 것
  * 다시 필요해지면 디스크에서 다시 불러와서 로드
  * 이 과정은 느리지만 전체 프로그램이 동시에 메모리에 존재하지 않아도 실행 가능
* 지연 로딩(Lazy Loading)
  * 프로그램이 필요한 데이터를 즉시 로드하지 않고, 사용되는 순간에 불러오는 전략
  * 자원 절약, 초기 실행 속도를 빠르게 하기 위해 사용
  * 사용자 경험에 영향을 줄 수 있으므로 적절한 사용 시점을 고려해야 함
  * 필요한 자원을 미리 로딩하는 선행 로딩이 필요한 경우에는 적합하지 않을 수 있음
* 예시 흐름
  1. 프로그램 실행, main()함수는 메모리에 로딩
  2. 특정 함수 foo()에 처음 접근, 해당 페이지는 아직 없음
  3. 페이지 폴트 발생, 운영체제가 디스크에서 해당 페이지 로딩
  4. 이후 foo()함수 실행, 지연 로딩 완료
* 스와핑과 지연 로딩
  * 지연 로딩은 메모리 효율성을 위해 차후에 로드
  * 스와핑은 이미 로드된 페이지를 잠시 내보냈다가 다시 불러오는 개념
  * 둘 다 메모리 압박을 줄이기 위한 동적 메모리 관리 기술

## 프로그램 실행, 함수 호출 과정
* 컴파일 과정
  1. 전처리기 단계 (#include, #define 등 처리)
  2. 컴파일 단계 : 소스 코드를 어셈블리어로 변환
  3. 어셈블 단계 : 어셈블리어에서 기계어로 변환, 오브젝트 파일 생성
  4. 링커 단계 : 여러 오브젝트 파일과 라이브러리 결합, 실행 파일 생성
  * 이 과정에서 함수 any()와 main()의 메모리 주소가 결정, 호출 단계 연결
* 프로그램 실행 시작
  * 운영체제가 실행 파일을 메모리에 로드, 프로세스 생성
  * 운영체제는 메모리 공간 할당, main()함수부터 실행 시작
  * 스택, 힙, 코드, 데이터 영역이 구성됨
* 함수 실행 순서
  * main() 함수 진입
    * 실행이 시작되면 main()함수의 스택 프레임 생성
    * 지역 변수, 매개변수 등이 스택에 저장
  * any() 함수 호출 (함수 호출 스택, Call Stack)
    1. 현재 위치(리턴 주소)를 스택에 저장
    2. any() 함수의 스택 프레임을 새로 생성
    3. 함수의 코드 작동
    4. 함수 종료, 스택 프레임 제거
    5. 저장된 리턴 주소로 복귀
  * 종료
    * main()함수가 끝나면 return 0;을 통해 종료 코드 반환
    * 운영체제가 프로세스를 정리하고 메모리 해제

***

_출처 : OSTEP (Operating Systems : Three Easy Pieces)_