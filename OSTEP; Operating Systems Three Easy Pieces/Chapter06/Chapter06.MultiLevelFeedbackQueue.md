## 멀티 레벨 피드백 큐 (MLFQ; Multi-Level Feedback Queue)
* Compatible Time-Sharing System(CTSS)에 사용
* 1962년 Corbato 등에 의해 소개됨
* 수년 동안 다듬어져 일부 현대 시스템에까지 발전
* 해결하려는 문제
  * 짧은 작업 먼저 실행, 반환 시간 최적화
  * SJF, STCF는 작업 실행 정보 필요, 사실상 미리 알 수 없음
  * 대화형 사용자를 위한 응답 시간 최적화
  * RR은 응답 시간을 단축시키지만 반환 시간은 거의 최악

### MLFQ : 기본 규칙
* 여러 개의 큐로 구성, 각 큐는 서로 다른 우선순위(Priority Level) 보유
* 실행 준비가 된 프로세스는 하나의 큐에 존재, 스케줄러는 우선순위를 기준으로 실행할 프로세스 결정
* 우선순위가 높은 큐의 작업 실행
* 같은 우선순위 큐에 있는 작업은 RR(라운드 로빈) 방식으로 실행
* **동적 우선순위**
  * MLFQ는 작업에 고정된 우선순위를 부여하지 않음
  * 작업의 실행 특성에 따라 동적으로 우선순위 부여
  * 예시
    * 키보드 입력을 기다리며 CPU를 자주 양보하는 작업은 높은 우선순위 유지 (I/O Bound Process)
    * 오랜 시간 CPU를 사용하는 작업은 우선순위가 낮아짐 (CPU Bound Process)
  * 작업이 진행되는 동안 해당 작업의 정보를 얻고, 이 정보를 이용해 미래 행동 예측
* **기본 규칙**
  * Priority(A) > Priority(B)이면 A가 실행
  * Priority(A) = Priority(B)이면 RR 방식으로 실행
* 우선순위가 높은 A, B와 낮은 C, D가 있을 때, A와 B를 번갈아 실행

### 시도 1 :우선순위의 변경
* 우선순위 조정 규칙
  * 규칙 3 : 새로 도착한 작업은 가장 높은 우선순위 큐에 들어감
  * 규칙 4a : 타임 슬라이스를 전부 사용하면, 우선순위가 낮아짐 (하위 큐로 이동)
  * 규칙 4b : 타임 슬라이스를 다 쓰기 전에 CPU를 양도하면 같은 우선순위를 유지
* 예시
  * 예시 1 : 긴 실행 시간의 작업
    * 작업은 가장 높은 큐에서 시작
    * 타임 슬라이스를 다 쓰면 점점 낮은 큐로 이동
    * 결국 가장 낮은 우선순위 큐에 머무르게 됨
  * 예시 2 : 짧은 작업과 함께 존재하는 경우
    * CPU 위주 긴 작업 : 낮은 우선순위 큐에 있음
    * 짧은 대화형 작업 : 높은 우선순위 큐에 도착
    * 대화형 작업은 짧은 시간 안에 종료되므로 우선순위가 떨어지기 전에 실행 완료
    * 결과적으로 MLFQ는 SJF와 유사하게 동작
  * 예시 3 : 입출력 중심 작업
    * 대화형 작업은 자주 CPU를 양도하므로 우선순위를 유지
    * 긴 작업과 경쟁할 때에도 높은 우선순위로 빠르게 실행
* 현재 MLFQ의 문제점
  * 기아 현상 (Starvation)
    * 대화형 작업이 너무 많으면 긴 작업은 CPU를 거의 배정받지 못 함
  * 우회 공격 가능성
    * 타임 슬라이스 종료 직전에 의도적으로 입출력 요청 시 우선순위 유지
    * 이로 인해 CPU를 독점하는 효과 발생 가능
  * 작업 특성의 동적 변화에 미비한 대응
    * CPU 중심 작업이 대화형으로 바뀌어도 낮은 우선순위에 그대로 남아 있음

### 시도 2 : 우선순위의 상향 조정 (Priority Boosting)
* 새로운 규칙 도입
  * 규칙 5 : 일정 시간 간격 S마다 모든 작업을 최상위 큐로 이동
* 기아 상태 방지
  * CPU 위주 작업도 주기적으로 최상위 큐에서 실행 기회 확보
  * 높은 우선순위 작업들과 Round Robin 방식으로 CPU를 공유
* 작업 특성 변화에 유연하게 대응
  * 작업이 대화형으로 바뀌면 자연스럽게 높은 우선순위에서 실행
* 상향주기(S)의 설정 문제
  * S는 부두 상수(Voodoo Constant, 적절한 값을 찾기 어려움)
  * 너무 크면 긴 작업이 기아 상태에 빠질 수 있음
  * 너무 작으면 대화형 작업이 응답성을 잃고 지연될 수 있음

### 시도 3 : 더 나은 시간 측정
* 문제 상황
  * 기존 규칙 4a/4b는 우선순위 유지를 조작할 수 있는 여지를 줌
  * 타임 슬라이스 종료 직전에 입출력 시 우선순위 유지, CPU 독점 가능
* 총 사용 시간 기반 우선순위 하락
  * 새로운 규칙 4 (통합) : 현재 단계에서 할당된 시간 총량을 소진하면, 우선순위 하락
  * 입출력 횟수나 CPU 양도 횟수 무관
  * CPU를 짧게 여러 번 쓰든 한 번에 오래 쓰든 총 사용 시간을 기준으로 판단
* 입출력 타이밍 조절로 우선순위를 유지하는 전략 차단
* 자기 몫만큼의 CPU 시간 사용으로 공정성 확보

### MLFQ 조정과 다른 쟁점들
* 스케줄러 조정이 필요한 요소
  * 큐의 갯수, 타임 슬라이스 크기, 우선순위 상향 조정 주기
  * 정해진 정답은 없으므로 워크로드에 따라 실험적으로 조정
* 타임 슬라이스의 차등 배정
  * 우선순위가 높은 큐
    * 짧은 타임 슬라이스 (10ms 이하)
    * 대화형 작업이 많아 빠른 응답성이 중요
  * 우선순위가 낮은 큐
    * 긴 타임 슬라이스 (수백 ms)
    * CPU 중심 작업에 적합
  * 큐별 타임 슬라이스 차등 배정
* 실제 구현 예시
  * Solaris
    * MLFQ 설정을 테이블 기반으로 관리
    * 큐 개수 : 60개
    * 타임 슬라이스 : 20ms부터 시작해 수백ms까지 점진 증가
    * 우선순위 상향 : 1초마다
    * 관리자가 테이블 수정으로 스케줄링 전략을 바꿀 수 있음
  * 다른 MLFQ 스케줄러 (FreeBSD)
    * 수학적 공식 기반
    * 사용한 CPU 시간을 기반으로 공식을 세워 우선순위 결정
    * CPU 사용 시간이 지나면 감쇠 (Decay)
    * 자연스럽게 우선순위 회복
* 추가 기능
  * 운영체제 전용 우선순위 : 최상위 우선순위는 OS용으로 예약
  * 사용자 지정 우선순위 조절
    * nice 명령어 등을 통해 작업 우선순위를 높이거나 낮춤
    * 사용자 실행 순서에 영향을 줄 수 있음
    
***

_출처 : OSTEP (Operating Systems : Three Easy Pieces)_