## 운영체제 (OS; Operating System)
* **프로그램의 실행**
  * 프로그램 실행 시, CPU는 반복적으로 세 단계를 수행
  * Fetch(반입, 명령어 읽기), Decode(해석), Execute(실행)
  * 명령어 작업 완료 후 다음 명령어 실행
  * 프로그램이 종료될 때까지 실행 반복
* **운영체제**
  * 슈퍼바이저(Supervisor), 주 제어 프로그램(Master Control Program)
  * 시스템을 사용하기 편리하면서 정확하고 올바르게 동작시키는 소프트웨어
  * 프로그램 실행, 프로그램 간의 메모리 공유, 장치와의 상호작용    
  * **가상 자원 생성**
    * 운영체제는 물리적 자원(CPU, 메모리, 디스크 등)을 가상 자원으로 추상화
    * 사용자가 더 일반적이고 편리하게 시스템을 사용할 수 있도록 함
    * 운영체제를 가상 머신 (Virtual Machine) 이라고도 부름
  * **시스템 콜 (System Call) 제공**
    * 사용자 프로그램이 운영체제의 기능을 요청할 수 있도록 API 제공
    * 수백 개의 시스템 콜을 통해 프로그램 실행, 메모리 접근, 파일 접근 등 수행
    * 표준 라이브러리(Standard Library)를 제공
  * **자원 공유 및 관리**
    * 자원을 효율적으로 공정하게 관리
    * 다수의 프로그램들이 CPU를 공유해 동시 실행
    * 각각의 프로그램들이 각자 명령어와 데이터에 독립적으로 접근 가능
    * 디스크 등의 장치 공유 가능
    * 운영체제를 자원 관리자 (Resource Manager) 라고도 부름

## 가상화 (Virtualization)
### CPU 가상화 (Virtualizing the CPU)
* 시스템을 사용하기 편리하게 만들기 위해 가상화 사용
* CPU 가상화 예시
  > 1. Spin() 함수 : 1초 동안 실행 후 리턴
  > 2. 이후 사용자 입력 문자열을 무한 반복하며 출력
  * 한 개의 인스턴스 실행 시, 1초마다 출력
  * 여러 인스턴스 실행 시, 동시에 실행되는 것처럼 보임
* CPU가 하나인데 동시에 실행되는 것처럼 보이는 이유
  * 운영체제가 하드웨어의 도움을 받아 가상의 CPU들이 존재하는 것처럼 보이게 함
  * 이것이 CPU 가상화 (Virtualizing the CPU)
  * 하나의 CPU로 다수의 프로그램을 동시에 실행시키는 환상 제공
* CPU 가상화를 위한 운영체제의 요소
  * API
    * 운영체제에 원하는 동작을 요청하는 인터페이스
    * 프로그램의 실행, 중단, 전환을 운영체제에게 전달하기 위해 필요
    * 사용자와 운영체제의 주요 상호작용 수단
  * 정책 (Policy)
    * 누가 실행되어야 하는가와 같은 문제 해결
    * 동시에 실행되기를 원하는 두 프로그램 중 누구를 먼저 실행할지 결정
  * 기법 (Mechanism)
    * 실제로 동시에 실행하는 것처럼 전환(Switching) 및 관리하는 방법
    * 운영체제가 자원 관리자로서 수행하는 역할

### 메모리 가상화 (Virtualizing Memory)
* 메모리의 물리적 모델
  * 물리 메모리(Physical Memory)는 단순한 바이트 배열
  * 메모리 접근 방식
    * 읽기 : 주소를 통해 데이터 반환
    * 쓰기 : 주소와 데이터로 저장 및 갱신
  * 메모리는 프로그램 실행 중 지속적으로 접근됨
  * 자료구조와 명령어 모두 메모리에 저장
* 메모리 가상화 예시
  > 1. malloc() 호출로 메모리 동적 할당
  2. 할당된 메모리 주소 출력
  3. 할당 메모리 첫 슬롯에 0 저장
  4. 이후 1초마다 값을 1씩 증가시키며 PID와 함께 출력
  * 이 프로그램을 여러 번 실행해도 모두 같은 주소 사용
  * 서로 독립적인 데이터 처리
  * 각각의 인스턴스가 자신만의 메모리를 가진 것처럼 작동
* 메모리 가상화의 작동 방식
  * 운영체제가 각 프로세스에 가상 주소 공간(Virtual Address Space) 제공
  * 프로세스마다 독립적인 메모리 공간이 존재하는 것처럼 보이게 함
  * 가상 주소 공간과 물리 메모리는 운영체제가 매핑 (Mapping)
  * 한 프로세스의 메모리 접근은 다른 프로세스에 영향 X
  * 실제로는 물리 메모리는 공유 자원, 운영체제가 효율적으로 관리

## 병행성 (Concurrency)
* 여러 작업을 동시에 처리하려 할 때 발생하고 해결해야 하는 문제
* 운영체제 수준의 병행성
  * 여러 프로세스를 순차적으로 빠르게 전환(Switching)하며 실행
  * 동시에 많은 일을 하는 것처럼 보이게 함
* 사용자 수준의 병행성
  * 멀티 쓰레드 프로그램에서 동일한 문제 발생
  * 여러 쓰레드가 같은 메모리 공간에서 함수를 동시 실행 시 발생
* 병행성의 예시
  > 1. pthread_create()로 쓰레드 2개 생성
  2. 두 쓰레드는 worker() 루틴 실행
    2-1. 공유 변수 counter 값 증가
  3. 각 쓰레드는 loops번 반복
  * 올바르게 실행될 경우, 입력이 N이라면 출력은 2N
  * loops가 1000일 경우 counter도 2000으로 맞을 수도 있음
  * loops가 100000일 경우 200000이 되어야 하나, 143012등 매 실행마다 다른 결과 도출
* 문제 발생 원인
  * counter를 증가시키는 명령어가 원자적(Atomic)으로 실행되지 않기 때문
  * counter를 증가시키는 내부 동작
    1. 메모리에서 레지스터로 counter값 읽기
    2. 레지스터의 값 1 증가
    3. 레지스터에서 메모리로 counter값 저장
  * 이 3단계는 하나의 연산처럼 보이나, 실제로는 분리된 명령어
  * 두 쓰레드가 동시에 counter를 업데이트하려 하면 경쟁 조건(Race Condition) 발생
    * 한 쓰레드가 값을 증가시키는 중에 다른 쓰레드가 중간값을 덮어씌울 수 있음

## 영속성 (Persistence)
* 휘발성 메모리의 한계
  * DRAM과 같은 주기억장치는 휘발성(Volatile)
  * 전원이 꺼지거나 시스템 고장(Crash) 시 모든 데이터 손실
* 비휘발성 저장 장치의 필요성
  * 데이터를 오래 보존하기 위해 I/O 장치 필요
  * Solid-State Drives(SSD), Hard Disk Drive(HDD)
  * 디스크의 관리는 운영체제의 파일 시스템(File System)이 담당
* 파일 시스템의 역할 및 예시
  * 사용자가 생성한 파일을 시스템의 디스크에 안전하고 효율적으로 저장
  * 프로그램에서의 운영체제 호출
    1. open() 콜 : 파일 생성
    2. write() 콜 : 파일에 데이터 저장
    3. close() 콜 : 파일 닫기, 더 이상 해당 파일을 사용하지 않음
  * 이러한 시스템 콜은 운영체제에서 파일 시스템으로 전달
  * 파일 시스템은 요청 처리, 경우에 따라 에러 코드 반환
* 운영체제가 디스크에 데이터를 쓰기 위한 동작
  1. 데이터를 디스크 어디에 저장할지 결정
  2. 자료구조를 통해 파일 상태 및 위치 추적
  3. 기존 자료구조를 읽거나 갱신
  * 실제 하드웨어와 통신하는 장치 드라이버(Device Driver) 필요
  * 단순 함수 호출 시, 운영체제는 내부에서 파일 시스템, 장치 드라이버, 저수준 인터페이스를 활용해 작업 수행
  * 마치 표준 라이브러리(Standard Library)처럼 동작
* 데이터 영속성을 위한 기법
  * 쓰기 지연 (Write Buffering) : 성능을 위해 여러 쓰기 요청을 모아 한번에 처리
  * 저널링 (Journaling) : 데이터를 쓰기 전, 로그(저널)에 기록해 Crash 발생 시 복구 가능
  * 쓰기-시-복사 (Copy-On-Write) : 안정성 확보를 위해 Write()콜이 발생했을때 데이터를 복사
  * 자료구조 : 단순 리스트부터 B-트리 같은 복잡한 구조까지 사용, 디스크 성능 최적화

## 운영체제의 설계 목표
* 편리한 추상화(Abstraction) 제공
  * CPU, 메모리, 디스크 같은 자원을 쉽게 사용할 수 있는 개념으로 변경 (추상화)
  * 추상화는 복잡한 시스템을 이해 가능한 단위로 나누는 핵심 수단
  * 고수준 언어 -> 어셈블리어 -> 논리 게이트 -> 트랜지스터
  * 운영체제는 계층 중간에서 사용자와 하드웨어를 잇는 중개자 역할 수행
* 성능 (Performance)
  * 운영체제는 오버헤드를 최소화(Minimize the Overhead) 해야 함
    * 시간 오버헤드 : 더 많은 명령어
    * 공간 오버헤드 : 더 많은 메모리/디스크 사용
  * 가상화나 보호 등 기능은 필수지만 과도한 오버헤드 없이 제공되어야 함
  * 현실적인 해결책을 위해 절출(Trade-Off)도 중요
* 보호 및 고립 (Protection and Isolation)
  * 여러 프로그램이 동시에 실행되기 때문에 운영체제는 다음을 보장해야 함
    * 한 프로그램이 다른 프로그램에게 해를 끼치지 않도록 보호
    * 프로그램이 운영체제를 위협하지 않도록 보호
  * 신뢰성 (Reliability)
    * 운영체제는 지속적이고 안정적으로 동작해야 함
    * 운영체제가 실패하면 모든 프로그램이 영향을 받음
* 기타 목표
  * 에너지 효율성 (Energy Efficiency) : 자연 친화적 발전
  * 보안 (Security) : 보호의 확장, 악의적인 공격에 대비
  * 이동성 (Mobility) : 작은 장치에서도 효율적 동작
  
## 운영체제의 간단한 역사
**운영체제가 발전해 온 간단한 역사
시간이 지남에 따라 더 좋은 아이디어가 축적**

### 초창기 운영체제 : 단순 라이브러리
* 운영체제는 단순한 라이브러리 수준의 기능만 제공
* 자주 사용하는 입출력 함수와 같은 API 제공
* 메인 프레임 시스템, 컴퓨터 관리자가 프로그램을 하나씩 수동 실행
* 오늘날 운영체제가 담당하는 작업 순서 결정은 관리자 몫
* 일괄 처리 시스템 (Batch Processing)
  * 여러 작업을 모아 컴퓨터 관리자가 일괄 처리
  * 당시 컴퓨터의 비용 문제로 대화형 처리 불가능

### 멀티프로그래밍 시대
* 운영체제다운 운영체제의 등장
* 메인 프레임에서 미니 컴퓨터 시대로 전환 (DEC의 PDP 시리즈)
  * 컴퓨터 가격 하락, 소규모 기관 단위 보급
  * 개발자 수 증가, 운영체제 기술 발전 촉진
* 멀티프로그래밍(Multiprogramming) 기법 사용
  * 한 번의 하나의 프로그램만 실행하면 CPU 시간 낭비
  * 여러 프로그램을 메모리에 올려두고 빠르게 번갈아가며 실행
  * ex) 입출력 대기 시간 동안 CPU는 다른 작업 수행
  * CPU 사용률 향상, 전체 시스템 효율 향상
  * 핵심 이슈
    * 메모리 보호(Memory Protection) 필요성, 프로그램간 메모리 침범 방지
    * 병행성(Concurrency) 문제 발생, 올바른 동기화 및 스케줄링 필요
    * 인터럽트 처리의 복잡성 증가, 안정적인 컨텍스트 전환 기술 요구
* Unix 운영체제 등장
  * Ken Thompson & Dennis Ritchie (Bell Lab)
  * Multics, TENEX, Berkeley Time Sharing System에서 영향
  * 복잡한 아이디어들을 간단하고 강력한 시스템으로 재구성
  * C언어 컴파일러 제공, 코드 가독성 높음, 소스 코드 배포
  * 전 세계 개발자들이 참여하며 기능 확장
  * Barkeley Systems Distribution (BSD, 배포판)
    * 향상된 가상 메모리, 파일 시스템, 네트워킹 기능
  * 인기가 높아지며 여러 회사들이 자체 버전 제작, 이후 법적 분쟁
  * Microsoft Windows의 PC 시장 주도
* Linux
  * Linus Torvalds가 개발
  * Unix의 원리와 개념 사용, 코드는 사용하지 않음
  * 오픈 소스, 무료, 수정에 용이
  * 대부분의 회사가 사용 (Google, Amazon 등)
  * 스마트폰의 확장으로 입지 확장

### 현대
* PC의 등장
  * 미니 컴퓨터 이후, 개인용 컴퓨터(PC)가 등장, 대중화 성공
  * 가격 하락, 그룹당 1대에서 사람당 1대로 전환
  * 운영체제 기술의 퇴보
  * DOS : 메모리 보호 기능 없음, 시스템 전체 손상 가능
  * Mac OS(v9 이전) : 협업 스케줄링 사용, 무한루프 발생 시 전체 시스템 정지
  * 미니 컴퓨터 시대의 기술적 진보 다수 소실 또는 무시
* 미니 컴퓨터 운영체제 기술 귀환
  * Mac OS X : Unix 기반, Unix의 모든 특성 보유
  * Windows NT : 운영체제 기술 크게 발전 (오늘날 Windows의 기반)
* 현재
  * 모바일 운영체제조차 Unix/Linux 계열
  * 미니 컴퓨터 시절 발명된 기술이 현재도 표준
  * 기능 추가, 사용자 편의성 개선 등 지속적인 발전

***
## 프로세스 vs 쓰레드
* **프로세스 (Process)**
  * 보조기억장치의 프로그램을 메모리에 적재하고 실행한 것
  * 독립된 메모리 공간 사용
  * 기본적으로 자원 공유 불가 (IPC; Inter-Process Communication 필요)
  * 다른 프로세스에 영향 없음
  * 같은 프로세스 여러개 생성 시 메모리 낭비
* **쓰레드 (Thread)**
  * 프로세스를 구성하는 실행의 흐름 단위
  * 같은 프로세스 내 자원 공유 (쓰레드ID, 레지스터 값, 스택을 제외한 영역 공유)
  * 자원 공유 가능, 단 동기화 필요
  * 오류 발생 시 프로세스 전체에 영향
  * 메모리를 효율적으로 사용, 협력과 통신에 유리

## 병행성(동시성) vs 병렬성
* **병행성 (동시성, Concurrency)**
  * 하나의 시스템이 여러 작업을 동시에 처리하는 것처럼 보이게 만든 것
  * 실제로는 한번에 하나의 작업만을 처리
  * 작업 간 빠른 전환
  * 싱글 코어에서도 동작 가능
* **병렬성 (Parallelism)**
  * 여러 작업을 실제로 동시에 처리하는 것
  * 속도 향상, 성능 최적화
  * 멀티 코어 필요