## 스케줄링 정책 (Scheduling Policy)
### 워크로드에 대한 가정
* **워크로드 (Workload)**
  * 시스템에서 일련의 프로세스들이 실행되는 상황
  * 스케줄링 정책을 설계할 때 워크로드에 대한 가정이 중요
  * 워크로드를 통해 정교한 정책 설계 가능
* **기본 가정 (비현실적)**
  * 실행 중인 프로세스 혹은 작업에 대한 가정
  > 1. 모든 작업은 동일한 실행 시간을 갖음
  > 2. 모든 작업은 동시에 도착함
  > 3. 작업은 중단 없이 한 번에 끝까지 실행됨
  > 4. 작업은 오직 CPU만 사용 (입출력 없음)
  > 5. 작업의 실행 시간이 미리 알려짐
  * 가정의 한계
    * 현실 시스템과는 많이 다름
    * 특히 작업의 실행 시간을 미리 안다는 가정은 거의 불가능 (대부분 예측이 어렵고 동적)
  * 목적
    * 비현실적인 가정이라도 정책 설계의 기초를 이해하는데 유용
    * 점차 가정을 완화하며 현실적인 정책으로 발전시킬 예정

### 스케줄링 평가 항목 (Scheduling Metric)
* 다양한 스켖줄링 정책을 비교 및 분석하기 위해 공통된 평가 기준 필요
* 워크로드에 대한 가정 외에 무엇을 좋다고 판단할지 기준을 세우는 것
1. 반환 시간 (Turnaround Time)
   * 가장 기본적인 성능 지표
   * T(turningaround) = T(complete) - T(arrival)
   * 모든 작업이 동시에 도착한다 가정할 때에는 T(turnaround) = T(completion)
   * 작업이 얼마나 빨리 끝나는지 평가하는 지표
2. 공정성 (Fairness)
   * 특정 작업만 지나치게 오래 기다리는 것을 방지
   * 성능과 공정성은 서로 상충됨
   * 성능 지표와 충돌할 수 있음
     * 어떤 작업을 반복해서 미루면 전체 성능은 좋아지지만, 그 작업은 공정성 악화

### 선입선출
* FIFO(First In First Out) 또는 FCFS(First Come First Served)
* 가장 먼저 도착한 작업을 먼저 실행하는 방식
* 가장 단순하고 구현이 쉬운 스케줄링 알고리즘
* 실행 시간이 같은 경우 원활하게 작동 (10s, 3개, 평균 20s)
* 실행 시간이 다른 경우
  * 100s, 10s, 10s 3개 가정
  * 평균 반환 시간은 110s로 대폭 증가
* 호위 효과 (Convoy Effect)
  * 긴 작업이 앞에 오면 뒤의 작업들이 불필요하게 오래 대기
  * 전체 시스템 성능 저하
* 작업 실행 시간이 고르게 분포된 워크로드에서는 좋음
* 작업 실행 시간이 다양할 경우 성능 저하 가능

### 최단 작업 우선
* SJF(Shortest Job First)
* 실행 시간이 가장 짧은 작업부터 먼저 실행하는 스케줄링 정책
* FIFO에서 110s, SJF에서는 50s ((10 + 20 + 120) / 3)
* 평균 반환 시간 기준으로 FIFO보다 2배 이상 향상된 성능
* 모든 작업이 동시에 도착한다는 가정 하에 SJF는 평균 반환 시간을 최소화하는 최적의 알고리즘
* 도착 시간 동일 가정 삭제
  * A : t=0 도착, 실행 시간 100s
  * B, C : t=10 도착, 실행 시간 10s
  * 평균 반환 시간 : (100 + 100 + 110) / 3 = 103.33s
  * 다시 호위 효과 (Convoy Effect) 발생

### 최소 잔여 시간 우선
* STCF(Shortest Time-to-Completion First) 또는 PSJF(Preeptive Shortest Job First)
* 선점형 최단 작업 우선 스케줄링
* 가정 3을 완화한 방법 (중단 가능, 문맥 교환)
* 실행 중인 작업보다 잔여 실행 시간이 더 짧은 새 작업이 도착하면 현재 작업 중단, 새 작업 실행
* 예시
  * 평균 반환 시간 : (120 + 10 + 20) / 3 = 50s
  * 새로운 가정 하에서 STCF가 최적의 스케줄링

### 새로운 평가 기준 : 응답 시간
* 기존의 STCF는 초기의 일괄 처리 시스템(Batch)에는 적합, 현대의 시분할(Time-Sharing) 시스테에는 부족
* 사용자와 상호작용하는 환경에선느 새로운 평가 기준 필요
* 응답 시간 : 작업이 시스템에 도착한 순간부터 처음으로 CPU에 할당되기까지의 시간
  * T(response) = T(first_run) - T(arrival)
* 예시
  * A : t=0 도착
  * B, C : t=10 도착
  * 평균 응답 시간 : (0 + 0 + 10) / 3 = 3.33s
* 문제점
  * STCF는 반환 시간은 최적, 응답 시간은 모든 작업에 대해 항상 짧지는 않음
  * 특히 마지막 작업은 다른 작업이 끝날 때까지 기다려야만 함
  * 인터렉티브 시스템에 부적절 (먼저 스케줄링 됐다는 이유만으로 10s 대기)
  * 응답 시간을 최적화하는 스케줄링 필요

### 라운드 로빈
* STFS 등의 스케줄러는 반환 시간 기준으로는 뛰어나지만 응답 시간이 느려 사용자 경험이 좋지 않음
* RR (Round Robin), 작업 시간이 끝날 때까지 기다리지 않음
* 각 작업을 고정된 시간만큼 실행 후 다음 작업에게 CPU를 넘김
* 고정된 시간 단위 : 타임 슬라이스 (Time Slice), 퀀텀(Quantum)
* 타임 슬라이스의 길이는 타이머 인터럽트 주기의 배수
* 타임 슬라이싱이라고도 함
* 예시
  * A, B, C 동시 도착, 실행 시간 5초, 타임 슬라이스 1초
  * 평균 응답 시간 : (0 + 1 + 2) / 3 = 1s
* 타임 슬라이스의 길이
  * 타임 슬라이스가 짧을 경우 : 빠른 응답 속도, 문맥 교환 비용 증가
  * 타임 슬라이스가 길 경우 : 문맥 교환 비용 감소, 응답 속도 저하, 호위 효과 발생
  * 문맥 교환 비용을 상쇄할 수 있을 만큼 길어야 하지만, 응답 시간이 너무 길어져서는 안 됨
  * 문맥 교환 비용 : 레지스터 저장/복원, 캐시, TLB 플래시, 분기 예측 갱신, 갱신 시 큰 비용 유발
* 상쇄 기법 (Amortization)
  * 비용을 상쇄하기 위한 일반적인 전략
  * 슬라이스가 10ms이고 문맥 교환 시간이 1ms라면 전체의 10% 낭비
  * 슬라이스를 100ms로 늘리면 문맥 교환 비율 1%
* 반환 시간 관점
  * 위의 예시와 동일한 경우 종료 시간은 각각 13, 14, 15
  * 평균 반환 시간 : 14s
  * RR은 반환 시간 기준으로 매우 나쁨
* 스케줄러 성능
  * SJF, STCF는 응답 시간은 나쁘나, 반환 시간은 빠름 (공정성이 낮음)
  * RR은 응답 시간은 좋으나, 반환 시간은 나쁨 (공정성이 높음)
  * "케이크를 먹으면서 동시에 보관할 수는 없다" : 응답 시간과 반환 시간 간의 절충 (Trade-Off) 필요
* 아직 입출력을 하지 않는다는 조건과 실행 시간을 알고 있다는 가정이 남음

### 입출력 연산의 고려
* 모든 현실적인 프로그램은 입력과 출력을 필요로 함 (없을 경우 프로그램은 무의미)
* 스케줄러는 CPU뿐 아니라 I/O 상황 또한 고려해야 함
* 입출력이 스케줄링에 미치는 영향
  * 입출력 요청 발생 시, 해당 작업은 CPU를 더 이상 사용하지 않음, 대기 상태 진입
  * 다른 작업이 CPU를 사용하도록 스케줄링 되어야 함
  * 입출력 완료 시, 인터럽트 발생, 준비 상태 복귀
  * 두 번의 의사 결정 필요 (요청 발생 시, 입출력 완료 시)
* 예시
  * A, B 실행 시간 50ms, A만 10ms 이후 입출력 10ms
  * STCF 기준 A를 10ms로 나눔, 짧은 작업이 A이므로 A 실행 이후 B 실행
  * A가 입출력 진행 시 B 실행
  * 이 과정을 반복해 CPU와 입출력이 동시에 병렬 처리
* CPU-I/O 중첩
  * 입출력 중심 작업 (I/O Bound) : CPU를 짧게 사용, I/O 요청이 많음
  * CPU 중심 작업 (CPU Bound) : 긴 시간 CPU 사용, I/O 거의 없음
  * 입출력 중심 작업 먼저 처리, 입출력 대기 중에 CPU 중심 작업 실행
  * 시스템 자원 활용도 (CPU Utilization) 증가
  * 사용자 체감 응답 속도 개선

### 만병통치약은 없다 (No More Oracle)
* 마지막 가정은 불가능한 가정
* 현실의 범용 운영체제는 작업의 정확한 실행 시간을 절대 알 수 없음
* 특히 사용자 프로그램은 매우 다양하고 예측 불가능한 실행 경로를 갖음
* 따라서 SJF나 STCF처럼 사전 정보를 기반으로 한 스케줄링은 실제로 불가능
* 사전 정보 없이도 괜찮은 성능을 내는 알고리즘 필요

***
## 게임 프로세스
### 게임 프로세스는 CPU Bound Process? I/O Bound Process?
* 게임 프로세스의 특성
  * 그래픽 렌더링 : 프레임당 수백~수천만 번의 수학 연산 (CPU + GPU Bound)
  * 물리 시뮬레이션 : 충돌 판정, 중력, 물리 연산 등 (CPU Bound)
  * AI 계산 : 경로 탐색, 전략 연산 등 (CPU Bound)
  * 사용자 입력 처리 : 마우스/키보드 입력 처리 등 (일시적 I/O Bound)
  * 네트워크 통신 : 온라인 멀티 플레이 (I/O Bound)
  * 오디오 처리 : 파일 읽기, 재생 (I/O Bound)
* 게임 프로세스는 CPU Bound와 I/O Bound 특성을 모두 가짐
* 하지만 전반적으로 CPU Bound의 성향이 조금 더 강함

### 게임 프로세스의 우선순위?
* OS는 CPU Bound Process보다 I/O Bound Process의 우선순위를 더 높게 둠
* 하지만 게임 프로세스는 실제로 낮은 우선순위를 부여하면 안 됨
  * 게임은 CPU Bound Process이지만, 동시에 응답성(Responsiveness)이 중요
    * 사용자 입력에 빠르게 대응, 렌더링 타이밍이 정확해야 함
    * 무조건 낮은 우선순위를 주면 프레임 드랍, 랙 발생
* 일반적으로 Foreground / Real-Time Priority로 동작
  * Windows에서 High 또는 Above Normal 우선순위 설정
  * Unity, Unreal Engine 등은 실행 시 우선순위 조정을 요청하는 코드 포함
![](https://velog.velcdn.com/images/kooysung/post/7562b333-9829-4089-8eac-bbbf14abb280/image.png)
  * 실제 게임의 우선순위, Process Explorer 참고
***

_출처 : OSTEP (Operating Systems : Three Easy Pieces)
[ThreadPriority](https://docs.unity3d.com/ScriptReference/ThreadPriority.html)_