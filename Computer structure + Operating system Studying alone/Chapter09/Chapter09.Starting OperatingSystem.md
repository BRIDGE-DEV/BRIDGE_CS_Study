# Chapter09. 운영체제 시작하기


## 운영체제란
* 모든 프로그램은 하드웨어를 필요로 함
* 시스템 자원, 자원 : 프로그램 실행에 마땅히 필요한 요소들, **하드웨어**
* 운영체제는 프로그램이므로 여느 프로그램과 마찬가지로 **메모리에 적재**되어야 함
* **커널 영역(Kernel Space)** : 운영체제는 특별하기 때문에 컴퓨터 부팅시, 메모리의 커널 영역에 따로 적재
* **사용자 영역(User Space)** : 커널 영역을 제외한 나머지 영역, 응용 프로그램 적재(Application Software)
  * 운영체제는 커널 영역에 적재되어 사용자 영역에 적재된 프로그램들에 자원 할당, 실행 도움
* 운영체제 사용 예시
  * 여러 프로그램을 사용할 때 메모리에 주소가 겹치지 않도록 적재
    * 실행할 프로그램을 메모리에 적재, 실행되지 않으면 삭제하며 지속적으로 메모리 자원 관리
  * 여러 프로그램이 실행되려면 CPU 필요, 어떤 프로그램이 먼저 사용할지와 얼마나 사용할지
    * 최대한 공정하게 여러 프로그램에 CPU 자원 할당
* 흔히 **정부에 비유**
  * 자원을 효율적으로 배분하고 규칙을 만들어 전체를 관리
  * 역할별로 부서가 나눠져있듯 관리할 자원별로 기능 분할(CPU 관리, 프로세스 관리 등)
* 운영체제가 없다면 개발자가 하드웨어를 조작하는 코드를 모두 직접 작성해야 함
  * 운영체제가 기능을 제공하기 때문에 간편하게 개발 가능
* 운영체제를 알아야하는 이유
  * 프로그램이기 때문에 개발자와 상호작용 가능
  * ex) 현재 하드웨어의 상태, 코드 실행 방식, 하드웨어상의 문제 등
  * 문제 해결의 실마리 탐색 가능, 오류 메시지 진단 가능

## 운영체제의 큰 그림

### 운영체제의 심장, 커널

#### 커널(Kernel)
* 운영체제의 핵심 서비스를 담당하는 부분
* 자원에 접근하고 조작하는 기능
* 프로그램이 올바르고 안전하게 실행되게하는 기능
* 어떤 커널을 사용하는지에 따라 자원 이용 양상, 성능의 차이 발생
* 이후 운영체제를 지칭할 때는 커널을 지칭한다 봐도 무방

#### 운영체제가 제공하는 서비스 중 커널에 포함되지 않는 서비스
* 사용자 인터페이스(UI; User Interface) : 컴퓨터와 상호작용할 수 있는 통로
  * 그래픽 유저 인터페이스(GUI; Graphic User Interface) : 그래픽을 기반으로 컴퓨터와 상호작용할 수 있는 인터페이스
	*	커맨드 라인 인터페이스(CLI; Command Line Interface) : 명령어를 기반으로 컴퓨터와 상호작용할 수 있는 인터페이스


### 클럭
* 컴퓨터 부품을 움직일 수 있게하는 시간 단위
* 클럭 신호가 빠르게 반복되면 컴퓨터 부품들은 그만큼 빠른 박자로 동작
* 일반적으로 클럭 속도가 높은 CPU는 일반적으로 성능이 좋음
* CPU 속도 단위로 간주하기도 함
* 헤르츠(Hz)단위로 측정, 1초에 클럭이 몇번 반복되는지
  * 1GHz = 1억(10^9)Hz
* 계속 일정한 클럭 속도를 유지하기보단 유동적으로 속도 조절
* 오버클럭킹 : 최대 클럭속도를 강제로 끌어올리는 기법
* 클럭 속도를 올린다고 무조건 CPU가 빨라지는 것은 아님 => 발열문제
* CPU 성능을 높이기 위해 코어와 스레드 수를 늘리는 방법 사용

### 코어와 멀티코어
* 현대적인 관점에서의 CPU
  * 여태까지 나온 '명령어를 실행하는 부품'은 오늘날 **코어**라는 용어로 사용
  * 명령어를 실행하는 부품을 여러개 포함하는 부품
  * 코어 : ALU + 제어장치 + 레지스터
* 멀티코어 CPU(멀티코어 프로세서)
  * 코어 여러개를 포함하고 있는 CPU
  * CPU의 연산속도가 꼭 코어 수에 비례해 증가하진 않음
  * 코어마다 처리할 연산이 적절히 분배되지 않는다면 연산속도 증가 X (조별과제)
    * 코어마다 처리할 명령어들을 얼마나 적절히 분배하느냐가 중요

### 스레드와 멀티스레드
* 스레드(thread) : 실행흐름의 단위
* 하드웨어적 스레드
  * 하나의 코어가 동시에 처리하는 명령어 단위
  * CPU에서 사용하는 스레드라는 용어는 하드웨어적 스레드
  * 지금까지 배운 CPU는 1코어 1스레드
  * 멀티스레드 프로세서(멀티스레드 CPU)
    * 하나의 코어로 여러 명령어 동시 처리
    * 8코어 16스레드
    * 명령어를 실행하는 부품 : 8개
    * 한 번에 처리 가능한 명령어 수 : 16개
    * 하이퍼스래딩 : 인텔의 멀티스레드 기술
* 소프트웨어적 스레드
  * 하나의 프로그램에서 독립적으로 실행하는 단위
  * 프로그래밍 언어나 운영체제에서 사용하는 스레드라는 용어는 소프트웨어적 스레드
  * 여러 기능이 동시에 수행되고 싶을 때 각각의 기능을 작동시키는 코드를 스레드로 만들면 가능
  * 하드웨어적 스레드와 소프트웨어적 스레드는 독립적
    * 1코어 1스레드 CPU에서 프로그램 여러부분 동시 실행 가능
* 멀티스레드 프로세서(멀티스레드 CPU)
  * 하나의 코어로 여러 명령어를 동시에 처리하는 기술
  * 핵심은 레지스터
  * 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러 개 준비
  * 레지스터 세트가 2개이면 2스레드 실행 가능
  * 프로그램의 입장에서 4스레드는 CPU 4개와 다름 없음
    * 하드웨어적 스레드를 **논리 프로세서**라고도 함
  

## 명령어 병렬 처리 기법

### 명령어 병렬 처리 기법(ILP; Instruction-Level Parallelism)
* 명령어를 빠르고 효율적이게 처리하기 위해 CPU를 쉬지 않고 작동시키는 기법
* 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리

### 명령어 파이프라인 (Instruction Pipeline)
* 명령어 처리 과정을 클럭 단위 분할
 1. 명령어 인출 (Instruction Fetch)
 2. 명령어 해석 (Instruction Decode)
 3. 명령어 실행 (Execute Instruction)
 4. 결과 저장 (Write Back)
* 같은 단계가 겹치지만 않으면 각 단계 동시 실행 가능, 명령어를 겹쳐 수행하면 효율적
* 공장 생산 라인같이 명령어 파이프라인에 넣고 동시에 처리하는 기법 => **명령어 파이프라이닝**
* 파이프라인 위험 (Pipeline Hazard)
  * 파이프 라인이 높은 성능을 가져오지만 특정 상황에선 실패
  * 데이터 위험, 제어 위험, 구조적 위험
  * 데이터 위험 (Data Hazard)
    * 명령어 간의 '데이터 의존성'에 의해 발생
    * 모든 명령어를 동시 처리 불가
    * > 명령어 1 : R1 <- R2 + R3
    * > 명령어 2 : R4 <- R1 + R5
    * > 명령어 1을 실행해야만 명령어 2 수행 가능
    * 데이터 의존적인 두 명령어를 무작정 동시에 실행하려할 시
  * 제어 위험 (Control Hazard)
    * 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생
    * 프로그램 카운터는 기본적으로 다음 주소 갱신, 실행했을 시 분기, 다음 처리 무쓸모
    * 분기 예측 (Branch Prediction) : 어디로 분기할지 예측, 그 주소 인출
  * 구조적 위험 (Structural Hazard)
    * 명령어를 겹쳐 실행하는 과정에서 다른 명령어가 같은 CPU 부품 사용하려 할 때 발생
    * 자원 위험 (Resource Hazard)라고도 함

### 슈퍼스칼라 (Superscalar)
* 파이프라이닝은 단일 파이프라인으로도 구현 가능, 대부분의 CPU는 여러개의 파이프라인 이용
* CPU 내부에 여러 개의 파이프라인을 포함한 구조 => 슈퍼스칼라
* 공장 생산 라인 여러개 배치, 인출/해석/실행/저장이 2개 이상씩 실행
* 슈퍼스칼라 프로세서 (슈퍼스칼라 CPU) : 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU, 멀티 스레드 프로세서
* 처리 속도가 더 빠르나, 데이터/제어/자원 위험에 취약

### 비순차적 명령어 처리 (OoOE; Out-of-Order Execution)
* 오늘날 CPU성능 향상에 크게 기여한 기법
* 명령어들을 순차적으로 실행하지 않는 기법
* 데이터 위험에서의 데이터 의존성이 없는 명령어 우선 처리
* 순서를 바꿔도 무방할 명령어를 먼저 실행해 파이프라인이 멈추는 것을 방지하는 기법
* 비순차적 명령어 처리가 가능한 CPU는 데이터 의존성을 가지고 있는지, 바꿔 실행할 수 있는지 판단해야함


## CISC와 RISC

### 명령어 집합
* 명령어의 세세한 생김새, 할 수 있는 연산, 주소 지정 방식 등은 CPU마다 조금씩 차이
* 명령어 집합(Instruction set), 명령어 집합 구조(ISA; Instruction Set Architecture)
  * CPU가 이해할 수 있는 명령어 모음
* ex) 아이폰과 인텔은 서로 다른 ISA를 사용하기 때문에 별도의 설정 없이 이동시키면 실행 불가
* ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어도 다름
* ISA : CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속
* CISC와 RISC는 ISA의 종류

### CISC (Complex Instruction Set Computer)
* 복잡하고 다양한 명령어들을 활용하는 CPU설계 방법
* 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 **가변길이 명령어**
  * 상대적으로 적은 수의 명령어로도 프로그램 실행 가능, 메모리 공간 절약
* CISC의 단점
  * 명령어가 너무 복잡 및 다양하기 때문에 실행시간이 불규칙적, 여러 클럭주기 필요
    * 파이프라인을 구현하는 데에 어려움
  * 복잡한 명령어는 사용 빈도가 적음

### RISC (Reduced Instruction Set Computer)
* CISC와 달리 명령어 종류가 적고 짧고 규격화, 되도록 1클럭 내외 실행 명령어 지향
  * 고정 길이 명령어 활용, 명령어 파이프라이닝에 최적화
* 메모리 접근을 단순화, 최소화 => 주소 지정 방식의 종류가 적음
  * 레지스터를 적극 활용, 범용 레지스터의 개수도 더 많음

### CISC vs RISC
| CISC | RISC |
| --- | --- |
| 복잡하고 다양한 명령어 | 단순하고 적은 명령어 |
| 가변 길이 명령어 | 고정 길이 명령어 |
| 다양한 주소 지정 방식 | 적은 주소 지정 방식 |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클럭에 걸쳐 명령어 수행 | 1클럭 내외로 명령어 수행 |
| 파이프라이닝하기 어려움 | 파이프라이닝하기 쉬움 |