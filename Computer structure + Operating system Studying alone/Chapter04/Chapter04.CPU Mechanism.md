# Chapter04. CPU의 작동 원리

---

# 4-1) ALU와 제어장치

---

**CPU** : 메모리에 저장된 명령어를 읽어들이고, 해석하고, 실행하는 장치. 

> **ALU** : 계산 담당
**제어 장치** : 명령어 읽고 해석
**레지스터** : 작은 임시 저장 장치
> 

---

## 1) ALU (Arithmatic Logic **U**nit)

---

- ALU는 산술 연산 장치로 계산을 담당하는 부품이다. 계산을 위해서는 피연산자와 수행할 연산이 필요함.
- 따라서 ALU는 **레지스터**를 통해 피연산자를 받아들이고, **제어장치**로 부터 연산을 알려주는 제어 신호를 받음.
- 연산의 수행 결과는 바로 메모리에 저장이 되지 않고 **레지스터**에 우선 저장됨.
    - CPU의 메모리 접근 속도가 레지스터보다 느리기 때문에 매 연산마다 메모리에 저장하면 CPU에 자주 접근하게 되어 프로그램 실행 속도가 느려지기 때문!
- ALU는 계산 결과와 함께 **플래그(Flag)**를 내보냄.  플래그는 연산 결과에 대한 추가적인 정보.
- 플래그의 종류
    - **부호 플래그**
        
        > 1 → 음수  
        0 → 양수
        > 
    - **제로 플래그**
        
        > 1 → 결과가 0  
        0 → 결과가 0이 아님
        > 
    - **캐리 플래그**
        
        > 1 → 올림수나 빌림수가 발생
        0 → 발생하지 않음
        > 
    - **오버플로우 플래그**
        
        > 1 → 오버플로우 발생
        0 → 발생하지 않음
        > 
    - **인터럽트 플래그**
        
        > 1 → 인터럽트가 가능한 상태
        0 → 불가능한 상태
        > 
    - **슈퍼바이저 플래그**
        
        > 1 → 커널 모드(cpu, 드라이버, 메모리 등의 모든 자원에 접근하고 명령 가능한 모드)
        0 → 유저 모드(사용자 접근 영역이 제한된 모드)
        > 
- 플래그는 **플래그 레지스터** 라는 레지스터에 저장됨.

---

## 2) 제어 장치

---

- 제어 장치는 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호인 **제어 신호**를 내보내고 명령어를 해석하는 부품.
- CPU 제조사마다 구현 방식, 명령어 해석 방식, 받고 내보내는 정보 등이 다름.

### 제어 장치가 받아들이는 정보

- **클럭 신호**
    - 컴퓨터의 모든 부품을 움직이는 시간 단위. 똑 - 딱 - 똑 - 딱 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나 ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들임.
    - 단, 한 클럭마다 컴퓨터의 모든 부품이 작동되는 것이 아니라, 클럭이라는 박자에 맞춰 작동하는 것!
    - 여러 클럭에 걸쳐 하나의 명령어가 실행되기도 함.
- **해석해야 하는 명령어**
    - CPU가 해석해야 하는 명령어는 **명령어 레지스터**에 저장.
    - 제어장치는 명령어 받아 해석 → 제어 신호 발생 → 수행 명령 알림.
- **플래그 레지스터 속 플래그 값**
    - 플래그 받아들이고 제어 신호 발생.
- **제어 버스로 전달된 제어 신호**
    - 제어버스 통해 입출력장치와 같은 외부로부터 전달된 제어신호 받음.

### 제어 장치가 내보내는 정보

- CPU 외부에 전달하는 제어 신호
    - 제어 버스로 제어 신호 내보냄. 메모리 / 입출력 장치로 전달
- CPU 내부에 전달하는 제어 신호
    - ALU, 레지스터에 전달하는 제어 신호
    

---

# 4-2) 레지스터

---

- 프로그램 속 명령어와 데이터는 레지스터에 저장됨. 따라서 레지스터 속 값을 보고 CPU 내에서 무엇이 실행되는지 확인 가능.
- CPU마다 레지스터 이름, 크기, 종류가 다양하지만 8개의 공통 포함 레지스터 존재.
    - **프로그램 카운터(PC)**
        - 메모리에서 읽을 명령어 주소 저장.
        - 명령어 포인터라고 부르기도 함.
    - **명령어 레지스터(IR)**
        - 방금 메모리에서 읽어 들인 명령어(해석할 명령어) 저장.
        - 제어 장치가 명령어 레지스터 속 명령어 받아들이고 해석해 제어 신호 보냄.
    - **메모리 주소 레지스터(MAR)**
        - 메모리 주소 저장.
        - CPU가 읽고자 하는 주소값을 주소버스로 보낼 때 거치게 됨.
    - **메모리 버퍼 레지스터(MBR)**
        - 데이터와 명령어를 저장하는 레지스터.
        - 메모리에 쓰고 싶은 값이나 메모리로부터 전달 받은 값은 MBR을 거침.
        - 데이터 버스로 주고 받을 값이 거치게 됨.
    - **범용 레지스터**
        - 일반적이고 다양한 상황에서 자유롭게 사용 가능한 레지스터.
        - 데이터와 주소 모두 저장 가능.
        - CPU에는 여러 개의 범용 레지스터가 존재.
    - **플래그 레지스터**
        - ALU 연산 결과에 따른 플래그 저장.
    - **스택 포인터**
        - 스택 주소 지정 방식에 사용되는 레지스터
    - **베이스 레지스터**
        - 상대 주소 지정 방식 중 베이스 레지스터 주소 지정 방식에 사용되는 레지스터

## 특정 레지스터를 이용한 주소 지정 방식

### 1) 스택 주소 지정 방식

- 스택은 한 쪽이 막혀 있는 구조이기에 최근 저장 값만 꺼낼 수 있음.
- **스택 포인터**는 스택의 꼭대기 가리키는 레지스터 (= 스택에 마지막으로 저장한 값의 위치, 스택에 얼마나 데이터 채워져 있는지 표시)
- 추가, 삭제마다 포인터가 가리키는 주소가 달라짐.
- 스택은 메모리 영역으로 존재하며, 다른 주소 공간과 달리 스택처럼 사용하기로 암묵적 약속됨.

### 2) 변위 주소 지정 방식

- 오퍼랜드 값(변위)와 특정 레지스터 값을 더해 유효 주소를 얻어 내는 주소 지정 방식
- 어떤 레지스터를 더하는지에 따라 2가지로 나뉨
    - **상대 주소 지정 방식**
        - 오퍼랜드 + **프로그램 카운터** ⇒ 유효 주소
        - PC로 읽어 들일 명령어로부터 오퍼랜드 만큼 이전, 이후에 접근.
    - **베이스 레지스터 주소 지정 방식**
        - 오퍼랜드 + **베이스 레지스터** ⇒ 유효 주소
        - 기준 주소인 베이스 레지스터로 부터 오퍼랜드 만큼 떨어진 거리에 접근.

---

# 4-3) 명령어 사이클과 인터럽트

---

## 명령어 사이클

---

- 하나의 명령어를 처리하는 정형화된 흐름.
- 프로그램은 수많은 명령어들로 이루어져 있고, 명령어들은 일정 주기가 반복되며 실행되는데, 이 주기를 **명령어 사이클**이라고 함.
- EX) 메모리에 저장된 명령어 실행
    - 1) 명령어를 메모리 → CPU로 가져옴 (**인출 사이클**)
    - 2) 제어 장치가 명령어 레지스터에 담긴 값 해석, 신호 발생 (**실행 사이클**)
- 하지만, 명령어 CPU로 가져와도 바로 실행 사이클로 넘어가지 못하는 경우 존재
    - EX) 간접 주소 지정 방식
    - 이 경우에는 메모리 접근을 한번 더 하는 **간접 사이클** 거침.
    

---

## 인터럽트(Interrupt)

---

- CPU의 작업을 방해하는 신호
- 인터럽트의 종류
    - **동기 인터럽트**
        - CPU에 의해 발생
        - CPU가 명령 수행하다 예상치 못한 상황 마주쳤을 때 EX) 프로그래밍 상의 오류
        - **예외**라고도 부름
    - **비동기 인터럽트**
        - 입출력장치에 의해 발생
        - CPU가 입출력장치에 입출력 작업 부탁하면 작업 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)을 보냄.
        - **하드웨어 인터럽트**라고도 부름
        - 효율적인 명령어 처리와 하드웨어 인터럽트간의 관계?
            - CPU가 입출력장치 작업이 끝날 때 까지 기다림 → 그 동안 다른 작업 처리 불가 → CPU 사이클 낭비
            - 따라서 입출력 작업 중에도 CPU가 효율적인 명령어 처리를 이어 나갈 수 있도록 인터럽트를 통해 작업 완료 알림을 보냄.
        - **하드웨어 인터럽트 처리 순서**
            - 입출력장치가 CPU에게 **인터럽트 요청 신호**를 보냄
            - CPU는 실행 사이클 끝나고 명령어 인출 전, 항상 인터럽트 여부 확인
            - CPU가 인터럽트 요청 확인하고, **인터럽트 플래그**를 통해 인터럽트 받아들일 수 있는지 여부 확인
            - 가능하다면 CPU가 현재까지의 작업 백업
            - CPU가 **인터럽트 벡터**를 통해 **인터럽트 서비스 루틴**을 실행
            - 루틴 실행 끝나면 백업해둔 작업 복구하여 실행 재개
        - **인터럽트 요청 신호**
            - 인터럽트가 CPU의 정상적인 실행 흐름 끊는 것이므로 끼어들어도 되는지 물어보는 것.
        - **인터럽트 플래그**
            - CPU가 인터럽트 요청 수용 위해 플래그 레지스터의 인터럽트 플래그가 활성화 되어있어야 함.
            - CPU가 중요한 작업을 처리 중이라면 무시함.
            - 위의 경우 어떤 요청이 와도 무시하지만, 플래그가 불가능이어도 무시할 수 없는 인터럽트가 존재함
                - 정전, 고장
        - **인터럽트 서비스 루틴**
            - CPU가 인터럽트 받아들이기로 하면, 인터럽트 서비스 루틴이라는 프로그램 실행.
            - 이는 인터럽트 처리 위한 프로그램으로, 인터럽트 핸들러라고도 함.
            - 인터럽트 요청이 어떻게 처리되고 작동되는지에 대한 정보로 이루어진 프로그램.
            - CPU가 인터럽트를 처리한다 = 인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 되돌아온다.
            - 인터럽트 서비스 루틴 역시 명령어 + 데이터로 이루어진 프로그램이기 때문에 레지스터들을 사용함.
        - **인터럽트 벡터**
            - CPU가 수많은 인터럽트 서비스 루틴을 구분하기 위한 정보.
            - 인터럽트 벡터를 통해 인터럽트 서비스 루틴의 시작 주소 알 수 있음.
            - 데이터 버스 통해 전달 받음.
        - **CPU의 기존 작업 재개 방법**
            - 인터럽트 이전에 수행하던 작업들은 CPU에 의해 **스택**에 백업됨.
            - 이후에 인터럽트 서비스 루틴의 시작 주소 위치한 곳으로 **프로그램 카운터** 값을 갱신하고 인터럽트 서비스 루틴을 실행.
            - 처리 후에는 스택에 저장된 값을 불러온 뒤 수행 재개.