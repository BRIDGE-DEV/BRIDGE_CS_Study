
#### 컴퓨터의 정보 단위?

**비트  :  0과 1을 나타내는 가장 작은 정보단위**

컴퓨터 종류와 운영체제에 관계없이 모든 종류의  디지털 데이터는 아날로그 전기 신호로 구현된다.


**물질을 이루는 가장 작은 단위인 원자**
![[Pasted image 20231031223515.png]]


![[Pasted image 20231031223631.png]]
	뇌에서 처리하는 모든 연산은 뉴런의 전기신호가 보내느냐(1) 보내지 않느냐(0)로 처리되어 비트와 유사성을 띈다.

비트가 n개라면 표현할 수 있는 정보의 가짓 수 는 2^n이 된다.
우리가 실행하는 프로그램은 모두 수십만에서 수백만 이상의 0과 1로 이루어져 있으며 이처럼 긴 0과 1을 표현하기 위해 비트보다 큰 단위를 사용한다.


![[Pasted image 20231103153617.png]]

SI라고 하는 국제 단위 시스템에선 접두사 M K G는 각각 10^3을 의미한다. 컴퓨터의 데이터의 크기 단위 또한 M K G를 사용해왔지만 실질적인 컴퓨터의 데이터는 이진법으로 표현하기에 실질적인 크기와 달랐다.

예를들어 표기상으로는 1KB는 1000byte이지만 실질적으로 1000에 가까운 2^10인 1024byte인 것이다.

이는 용량이 커질 수록 더 큰 차이를 불러온다.
![[Pasted image 20231103172830.png]]
그래서 1998년 IEC(International Electrotechnical Commission)에서는 단위사이에 i를 추가해서 새로운 단위를 만들어 냈다.
![[Pasted image 20231103173328.png]]

#### 이진법

**이진법 : 모든 숫자를 0과 1로 표현하는 방법**
십진법은 숫자를 0에서 1씩 더해나갈 때 그 숫자가 10이되려하면 자리 올림을 한다.
마찬가지로 이진법 또한 숫자가 2가 되려하면 자리 올림을 해서 표현한다.

십진법을 먼저 예시로 들자면 모든 숫자를 0~9로 표현하는 방법이다.
십진수 365는 십진법의 식으로 

> (3x10^2)+(6x10^1)+(5x10^0) 

으로 표현할 수 있다.



다시 이진법으로 넘어와서 반대로 이진수 11001을 십진법으로 변환해보면

> (1x2^4)+(1x2^3)+(0x2^2)+(0x2^1)+(1x2^0)=16+8+0+0+1=25

이런식으로 계산해서 25가 나온다는 것을 알 수 있다.

#### N진법 계산

N진법으로 표현된 숫자 365가 있다고 했을때 십진법으로 변환하는 방법은

>(3xN^2)+(3xN^1)+(3xN^0) 

으로 표현할 수 있다.

#### 이진수의 표현

- xxxx2와 같이 끝에 2를 붙이는 방식 - 수학적
- xxxx₍₂₎와 같이 아래첨자를 붙이는 방식 - 수학적
- xxxxB와 같이 B를 붙이는 방식 - 어셈블리어
- 0bxxxx와 같이 0b를 앞에 붙이는 방식 - c++11 , 파이썬 등



#### 이진수의 음수 표현

이진수의 음수표현은 *2의 보수-two's complement*를 구해서 그 값을 음수로 간주하는 방법

**2의 보수  :  어떤 수를 그보다 큰 2^n에서 뺀 값**

>11₍₂₎보다 큰(3보다 큰)  2^n=100₍₂₎(십진수 4)
>
100₍₂₎-11₍₂₎=01₍₂₎
>
즉 11₍₂₎의 2의 보수는 01₍₂₎

좀 더 쉬운 방법은 *모든 0과 1을 뒤집고 1을 더하면*된다.

>11₍₂₎
>
>뒤집기
>
>00₍₂₎
> 
>1 더하기
>   
>01₍₂₎

1011₍₂₎의 2의 보수 구하기

>1011₍₂₎
>
>뒤집기
>
>0100₍₂₎
> 
>1 더하기
>   
>0101₍₂₎

1011₍₂₎의 2의 보수는 0101₍₂₎이다. 반대로 0101₍₂₎의 2의 보수는 1011₍₂₎이다.

>0101₍₂₎
>
>뒤집기
>
>1010₍₂₎
> 
>1 더하기
>   
>1011₍₂₎

1011₍₂₎의 음수인 0101₍₂₎은  양수 5의 이진법인 0101₍₂₎과 같은 형태이다.
이를 구분하기 위해 컴퓨터 내부에서는 *플래그(flag)* 를 사용한다.

**플래그 : ALU에서 연산결과값을 내보낼 때 결과값에 대한 부가정보 - 플래그 레지스터에 저장된다.**

연산결과에 오버플로우가 일어났는지에 대한 오버플로우 플래그나 결과값이 0인지 아닌지에 대한 제로플래그 등이 있다.

음수인지 양수인지에 대한 플래그는 *부호플래그*

#### 2의 보수의 한계

0이나 2^n형태는 2의 보수를 취하면 원하는 값을 얻기 힘들다.

>1000₍₂₎  (2^n형태인 2^3 = 8)
>
>뒤집기
>
>0111₍₂₎
> 
>1 더하기
>   
>1000₍₂₎ (바꾸기 전과 값이 같다...!)

n비트로는 -2^n과 2^n이라는 수를 동시에 표현할 수 없다.

>0000₍₂₎  (0을 음수로 표현하기)
>
>뒤집기
>
>1111₍₂₎
> 
>1 더하기
>   
>10000₍₂₎

이 경우에는 올림이 발생한 비트의 1을 버리면 된다.

#### 16진법

**16진법 :  모든 숫자를 1~9~A~F로 표현하는 방법**

이진법의 0과 1로 표현하기에는 숫자가 너무 길어지기 때문에 10, 11 ,12, 13, 14, 15의 숫자를 A, B, C, D, E, F 로 치환하는 16진법을 자주 사용한다.

![[KakaoTalk_20231101_172613277.jpg]]

16진수 또한 이진수와 마찬가지로 아래첨 ₍₁₆₎을 붙이거나 앞에 0x를 붙여서 표현한다.

#### 십육진법을 사용하는 이유?

**이진수와 십육진수사이의 변환이 쉽기 때문에**

십육진수는 한 자리 숫자에 0~9, A~F로 열여섯 종류의 숫자를 표현할 수 있다.
십육진수 한 자리는 이진수로 표현할 때 4비트가 필요한다. (2^4=16)
0=0000 ~ F=1111

EX) 1AD4₍₁₆₎를 이진수로 바꿀 때 각 글자를 이진수로 치환해서 이어붙이면 된다.
>1 ₍₁₆₎=0001₍₂₎
>A ₍₁₆₎=1010₍₂₎
>D ₍₁₆₎=1101₍₂₎
>4 ₍₁₆₎=0100₍₂₎
> 
>1AD4 ₍₁₆₎=0001 1010 1101 0111₍₂₎

참고로 십진수로 치환하는 방법은 다음과 같다
> (1x16^3)+(10x16^2)+(13x16^1)+(4x16^0)=6868

반대로 이진수를 십육진수로 변환하는 방법은 이진수를 4자리씩 끊어서 바꾸면 된다.

> 11010101₍₂₎ => 1101 0101₍₂₎
> 
>1101₍₂₎=D ₍₁₆₎
>0101₍₂₎=5 ₍₁₆₎
> 
>1101 0101₍₂₎=D5 ₍₁₆₎




#### 문자집합과 인코딩

**문자집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음**

**문자 인코딩 : 문자집합에 속한 문자를 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정**

**문자 디코딩 : 반대로 0과1을 문자집합의 문자로 변환하는 과정**


#### 아스키 코드

**아스키 (ASCII : American Standard Code for Information Interchange )** 는 초창기 문자 집합 중 하나

영어 알파벳, 아라비아 숫자, 일부 특수문자 , 제어문자 코드를 포함한다.

아스키 문자는 각각 7비트로 표현되며 총 128개의 문자를 표현할 수 있다.(2^7=128)

![[Pasted image 20231101174708.png]]

**코드 포인트(code point) : 문자 인코딩시 문자에 부여된 고유의 값**

#### EUC-KR

한글 인코딩 방식에는 **조합형 인코딩** 과 **완성형 인코딩**방식이 있다.

![[Pasted image 20231102224002.png]]

EUC - KR은 대표적인 **완성형 인코딩**이다.

2350개 가량의 한글 단어를 표현할 수 있지만 자주 쓰이지 않는"쀍, 쀓, 믜"같은 글자는 문자집합에 해당되지 않아 표현할 수 없다.

마이크로소프트에서 CP949라는 EUC-KR의 확장버전이 등장했으나 이마저도 한글 전체를 표현하기엔 어렵다.

#### 유니코드와 UTF-8

언어 하나마다 인코딩 방식을 채택하는 것은 비효율적이다.
그래서 모든 나라의 언어의 문자집합과 통일된 표준 인코딩 방식을 사용하는 **유니코드** 문자집합이 등장했다.
대부분 나라의 문자, 특수문자, 이모티콘, 등등 현대 문자를 표현할 때 가장 많이 사용되는 표준 문자 집합이다.

유니코드를 인코딩하는 방식에는 UTF-8, UTF-16, UTF-32 등이 존재하지만 가장 대중적으로 사용되는 것은 **UTF-8**이다.

*참고로 UTF-8은 조합형 인코딩과 완성형 인코딩 방식을 동시에 사용한다. *

![[Pasted image 20231102225825.png]]

**기본 다국어 평면(Basic Multilingual Plane 이하 BMP)**

가장 많이 차지하고 있는 언어는 한자, 그 다음이 한글이다.
한글은 11과 AC~D7에 위치한다.


진법 변환 계산기
https://www.digikey.kr/ko/resources/conversion-calculators/conversion-calculator-number-conversion

![[Pasted image 20231102231218.png]]

유니코드 차트
https://unicode.org/charts/

땨


11101011 10010101 10101000

100000000

1110-1000 10-100000 10-000