# Chapter10. 프로세스와 스레드


## 프로세스 개요

**프로세스(Process)** : 보조기억장치의 프로그램을 메모리에 적제하고 실행한 것

### 프로세스 직접 확인
* 윈도우에선 작업관리자 프로세스 탭에서 확인 가능
* **포그라운드 프로세스(Forground Process)** : 사용자가 볼 수 있는 공간에서 실행되는 프로세스
* **백그라운드 프로세스(Background Process)** : 보이지 않는 공간에서 실행되는 프로세스
* **데몬(Daemon), 서비스(Service)** : 사용자와 상호작용하지 않는 백그라운드 프로세스

### 프로세스 제어 블록
* 모든 프로세스는 CPU를 필요로하지만 CPU자원은 한정적
* 순서대로 한정된 시간만큼만 CPU 이용
* 그 후, 시간이 끝났음을 알리는 인터럽트(타이머 인터럽트) 발생하면 다음 차례 대기
  * 클럭 신호를 발생시키는 장치에 장치에 의해 주기적으로 발생, 타임아웃 인터럽트라고도 함
* 운영체제는 프로세스의 실행 순서 관리 및 자원 배분
* 이를 위해 **프로세스 제어 블록(PCB; Process Control Block)** 이용
* **프로세스 제어 블록**
  * 프로세스와 관련된 정보를 저장하는 자료구조 (상품의 태그)
  * 해당 프로세스를 식별하기 위해 꼭 필요한 정보 저장
  * 커널 영역에 생성되어 운영체제가 특정 프로세스를 식별하고 처리하는데 필요한 정보 판단
  * 프로세스 생성시 생성, 종료시 폐기 (운영체제가 주체)
* **PCB 내부 정보**
  * 프로세스 ID(PID; Process ID) : 프로세스를 식별하기 위해 부여하는 고유 번호
  * 레지스터 값 : 이전까지의 작업을 이어 실행할 수 있도록 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값
  * 프로세스 상태 : 현재 프로세스의 상태 (입출력 장치 대기, CPU 대기, CPU 사용중 등)
  * CPU 스케줄링 정보 : 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
  * 메모리 관리 정보 : 프로세스마다 메모리 저장 위치 상이, 주소 저장 정보, 베이스레지스터&한계레지스터 값, 페이지 테이블 정보 포함
  * 사용한 파일, 입출력장치 목록 : 실행 과정에서 특정 입출력장치나 파일을 사용시 해당 내용 명시


### 문맥 교환
* 하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어갈 경우
* ex) 프로세스A가 시간이 다 되어 프로세스B에게 사용 양도
* 직전 프로세스의 프로그램 카운터, 레지스터 값, 메모리 정보 등의 중간 정보를 백업해야 함
  * 다음 차례가 왔을 때 이전 내용에 이어 실행을 재개할 수 있어야 하기 때문
* **문맥(Context)**
  * 중간 정보, 하나의 프로세스 수행을 재개하기 위해 저장해야할 정보
  * PCB에 기록되는 정보들을 문맥이라고 봐도 무방
  * 예기치 못한 상황으로 인터럽트 발생시에도 PCB에 문맥 백업
  * 이후 다음 프로세스의 문맥을 복구해 실행되는 프로세스 변경
* **문맥 교환(Context Switching)**
  * 기존 프로세스의 문맥을 PCB에 저장, 새로운 프로세스의 문맥을 복구해 새로운 프로세스를 실행하는 것
  * 프로세스A의 문맥을 PCB에 저장 => 프로세스B의 PCB로부터 문맥 불러오기 => 프로세스B 실행
  * 문맥 교환이 자주 일어나면 동시 실행으로 보임, 너무 자주하면 오버헤드 발생


### 프로세스의 메모리 영역
* 프로세스가 생성되면 커널 영역에 PCB생성
* 하나의 프로세스는 사용자 영역에 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장
* **코드 영역(Code Segment)**
  * 텍스트 영역(Text Segment)라고도 함
  * 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
  * 데이터가 아닌 명령어가 저장되어있어 쓰기 금지
  * 읽기 전용 공간, read only
* **데이터 영역(Data Segment)**
  * 프로그램이 실행되는 동안 유지할 데이터 저장
  * 전역변수(Global Variable)가 대표적
* **힙 영역(Heap Segment)**
  * 프로그래머가 직접 할당할 수 있는 저장 공간
  * 프로그래밍 과정에서 힙 영역에 할당했다면 언젠가는 반환해야함
  * 반환하지 않는다면 메모리에 계속 남아 메모리 낭비 초래 => 메모리 누수(Memory Leak)
* **스택 영역(Stack Segment)**
  * 데이터를 일시적으로 저장하는 공간
  * 함수 실행 종료시 사라지는 매개변수, 지역변수가 대표적
  * 저장할 데이터 PUSH, 필요하지 않은 데이터 POP
* 코드 영역과 데이터 영역은 명령어들이 갑자기 바뀔 일이 없고 실행되는 동안 유지 => 정적 할당 영역
* 힙 영역과 스택 영역은 실행 과정에서 크기가 변화할 수 있음 => 동적 할당 영역
  * 힙 영역은 낮은 주소에서 높은 주소, 스택 영역은 높은 주소에서 낮은 주소 할당 => 주소 겹침 방지


## 프로세스 상태와 계층구조
* 프로세스는 모두 저마다의 상태가 있음
* 운영체제는 상태를 PCB에 넣어 관리
* 많은 운영체제는 동시에 실행되는 수많은 프로세스를 계층적으로 관리


### 프로세스 상태
* 여러 프로세스들이 빠르게 번갈아가며 실행되는 중 하나의 프로세스는 여러 상태를 거치며 실행
* 운영체제는 프로세스 상태를 PCB를 통해 인식하고 관리
* **생성 상태(New)**
  * 이제 막 메모리에 적제되어 PCB를 할당받은 상태
* **준비 상태(Ready)**
  * 당장이라도 CPU를 할당받아 실행 가능
  * 자신의 차례가 아니기에 기다리고 있는 상태
  * 준비 상태에서 실행 상태로의 전환 : **디스패치(Dispatch)**
* **실행 상태(Running)**
  * CPU를 할당받아 실행중인 상태
  * 실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU사용 가능
  * 할당 시간을 모두 사용한다면(타이머 인터럽트가 발생하면) 다시 준비 상태
  * 실행도중 입출력장치를 사용해 작업을 기다려야한다면 대기 상태
* **대기 상태(Blocked)**
  * 입출력장치를 사용하는 경우 입출력을 끝낼 때까지(입출력 완료 인터럽트 수신까지) 대기 상태
  * 입출력 작업 완료시 다시 준비상태로 전환, CPU 할당 대기
* **종료 상태(Terminated)**
  * 프로세스가 종료된 상태, 운영체제는 PCB와 프로세스가 사용한 메모리 정리
* **프로세스 상태 다이어그램(Process State Diagram)**
  * 다이어그램으로 도식화, P298 참조
* 대기 상태의 일반적인 정의
  * 대기 상태가 되는 이유에 입출력 작업만 유일하지 않음, 특정 이벤트를 기다릴 때, 대부분 입출력 작업


### 프로세스 계층구조
* 프로세스는 실행도중 시스템 콜을 통해 다른 프로세스 생성 가능
* **부모 프로세스(Parent Process)** : 새 프로세스를 생성한 프로세스
* **자식 프로세스(Child Process)** : 부모 프로세스에 의해 생성된 프로세스
* 부모, 자식 프로세스는 엄연히 다른 프로세스이므로 PID가 다름
  * 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID(Parent PID) 기록
* 자식 프로세스는 실행 과정에서 또 다른 자식 프로세스 생성 가능
* 많은 운영체제는 프로세스를 낳는 계층 구조로 프로세스 관리
* **프로세스 계층 구조** : 프로세스가 프로세스를 낳고 관리하는 것을 도표로 그린 트리 형태의 구조
  * 최초의 프로세스
    * 모든 프로세스의 가장 위에 있는 최초의 프로세스
    * 최초의 프로세스의 PID는 1번, 모든 프로세스의 부모 프로세스
    * 유닉스 : init, 리눅스 : systemd, macOS : launchd
    * 윈도우는 cmd에서 tasklist, system


### 프로세스 생성 기법
* 부모 프로세스가 자식 프로세스를 생성하는 방법, 자식 프로세스의 실행 과정
  * 윈도우와는 관련이 없으나, 많은 운영체제의 핵심 개념
* **복제와 옷 갈아입기** : 부모 프로세스를 통해 생성된 자식 프로세스의 실행
* 부모 프로세스는 **fork**를 통해 자신의 복사본을 자식 프로세스로 생성
* 자식 프로세스(만들어진 복사본)는 **exec**를 통해 자신의 메모리 공간을 다른 프로그램으로 교체
* fork와 exec는 시스템 콜
* **fork 시스템 콜**
  * 자신의 복사본을 자식 프로세스로 생성
  * 부모 프로세스의 자원들(메모리 내용, 열린 파일 목록 등)이 상속
  * 복사된 자식 프로세스이더라도 PID 값이나 저장된 메모리 위치는 상이
* **exec 시스템 콜**
  * fork로 복사본 제작 후 exec를 통해 새로운 프로그램으로 전환
  * 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 콜
  * 새로운 옷으로 갈아입었다 볼 수 있음
  * 호출 시 코드 영역, 데이터 영역은 실행할 프로그램으로 전환, 스택 영역, 힙 영역은 초기화
* 부모가 자식 프로세스를 실행하며 프로세스의 계층 구조를 이루는 과정은 fork와 exec의 반복


## 스레드(Thread)
* 프로세스를 구성하는 실행의 흐름 단위
* 하나의 프로세스는 여러 개의 스레드 소유
* 사용시 하나의 프로세스에서 여러 부분 동시 실행 가능


### 프로세스와 스레드
* 전통적인 관점에서 하나의 프로세스는 하나의 일만을 처리
* **단일 스레드 프로세스** : 실행의 흐름 단위가 하나
* **멀티스레드 프로세스** : 스레드라는 개념이 도입되며 프로세스를 구성하는 여러 명령어 동시 실행 가능
* 스레드 내부
  * 각기 다른 스레드 ID, 프로그램 카운터 값을 비롯한 레지스터 값, 스택으로 구성
  * 이러한 내부 구성 요소로 각기 다른 코드 실행
  * 실행에 필요한 최소한의 정보만을 유지한 채 프로세스 자원을 공유하며 실행
  * 코드/데이터/힙 영역은 공유
  * 많은 운영체제는 프로세스가 아닌 스레드 단위로 작업 전달
* 리눅스 운영체제에선 프로세스와 스레드 모두 실행의 문맥이라 동등하다고 간주해 태스크(task)로 통일해 명명


### 멀티프로세스와 멀티스레드
* **멀티 프로세스(MultiProcess)** : 여러 프로세스를 동시에 실행하는 것
* **멀티 스레드(MultiThread)** : 여러 스레드로 프로세스를 동시에 실행하는 것
* 동일한 작업을 수행하는 단일 프로세스 여러개 vs 하나의 프로세스를 여러 스레드
  * ex) "hello"를 출력하는 프로세스를 fork 3번, 스레드 3개
  * 프로세스끼리는 자원 공유하지 않음, 스레드끼리는 같은 프로세스 내의 자원 공유
  * 전자의 경우, 코드 영역, 데이터 영역 등의 모든 자원이 복제되어 메모리에 저장
  * 메모리 주소를 제외한 모든 것이 동일한 프로세스 생성으로 메모리 낭비가 일어남
    * =>PCB가 여러개
  * 후자의 경우, 스레드 ID, 레지스터 값, 스택을 제외한 자원 공유
  * 병행 실행보다 메모리 효율적 이용, 협력과 통신에 유리
    * =>PCB 하나
* 멀티스레드의 단점
  * 멀티프로세스에선 하나의 문제가 생겨도 다른 프로세스엔 지장이 없거나 적음
  * 멀티 스레드에선 하나의 스레드에 문제가 생기면 다른 스레드의 영향이 큼
  * 자원을 공유하기 때문

### 프로세스간 통신(IPC; Inter-Process Communication)
* 기본적으로 프로세스끼리는 자원을 공유하지 않지만 가능하긴 함
* 같은 컴퓨터 내의 프로세스나 스레드끼리 데이터를 주고 받는 것도 통신
* **파일을 통한 프로세스간 통신** : 같은 파일을 사용하는 프로세스간 통신
* **공유 메모리(Shared Memory)** : 서로 공유하는 메모리 영역
* 이외에도 소켓, 파이프 등을 통해 통신 가능, 스레드에 비해 까다로울뿐 가능