# Chapter03.Command

# 1. 소스코드와 명령어

---

**모든 소스 코드는 컴퓨터 내부에서 명령어로 변환된다.**

소스 코드 → 고급 언어 

명령어 → 저급 언어

## 고급 언어(High-Level Language)

---

컴퓨터와 소통을 위해 사람이 이해하고 작성하기 쉽게 만들어진 언어. C, C++, Java, Python과 같은 프로그래밍 언어. 저급 언어로 변환될 때 **컴파일 방식**과 **인터프리트 방식**이 사용된다.

### 컴파일 언어

---

소스 코드 전체가 저급 언어로 변환되어 실행되는 언어. ex) C, C++

컴파일 도중 오류가 발생하면 소스 코드 전체가 실행 중지 됨.

### 인터프리터 언어

---

인터프리터에 의해 소스 코드가 한 줄 씩 저급 언어로 변환되어 실행되는 언어. ex) Python

인터프리트 중 오류가 발생하면 오류 발생 전 지점까지는 실행 됨. 

### 컴파일 언어 vs 인터프리터 언어

---

일반적으로 인터프리터 언어는 컴파일 언어보다 느리다.

컴파일은 저급 언어로 번역이 된 책을 컴퓨터에게 직접 전달(실행)해주는 반면,

인터프리터는 컴퓨터에게 한 줄 씩 저급 언어로 해석하며 설명(실행)해야 하기 때문이다.

모든 프로그래밍 언어가 컴파일 언어와 인터프리터 언어 반드시 둘 중 하나의 방식만으로 작동하지는 않는다. 비율만 다르게 동시에 수행하는 경우가 많다.

## 저급 언어(Low-Level Language)

---

컴퓨터가 직접 이해하고 실행할 수 있는 언어. 기계어, 어셈블리어

컴파일 같은 번역 작업이 필요하지 않아 속도가 빠르다.

### 기계어(Machine Language)

---

- 0과 1의 명령어 비트로 구성된 2진 숫자 언어. 2진수로 나열하면 너무 길어지기 때문에 가독성을 위해 16진수로 표현하기도 한다.
- 프로그램은 기계어로 번역되어야만 컴퓨터가 그 내용을 이해하고 작동한다. 즉, 기계어는 컴퓨터의 **하드웨어가 유일하게 이해할 수 있는 언어**이다.
- 인간이 짠 소스 코드를 기계어로 번역하려면 어셈블러나 컴파일러가 필요하다.
- 기계어를 1세대 프로그래밍 언어라고도 한다.

1101 1001 1001 1111

1111 1100 1010 1100

…

### 어셈블리어(Assembly Language)

---

- 0과 1로 표현된 기계어를 읽기 편한 형태로 번역한 언어. 기계어에서 한 단계 위에 있는 저수준 언어.
- 어셈블리어로 작성한 원시 프로그램은 어셈블러를 통해 기계어로 어셈블 하는 과정을 거쳐야 한다.
- 임베디드 시스템, 커널 프로그램 등에서 필요하다.
- 어셈블리어의 기본 동작은 동일하지만 작성 CPU마다 사용되는 어셈블리어가 다를 수 있다.

> 고급 언어로 작성한 원시 프로그램을 컴파일러가 기계어로 번역하는 작업을 **컴파일(Compile)**한다고 하고,  어셈블리어로 작성한 원시 프로그램을 어셈블러가 번역하는 작업을 **어셈블(Assemble)**한다고 한다.
> 

push

pop

mov

…

### 게임 개발자가 어셈블리어를 왜 많이 이용하는가?

---

옛날에 어셈블리어로 게임 개발을 자주 했었다. 컴퓨터의 하드웨어와 근접한 저수준의 언어다 보니 최적화가 매우 잘 되었다. ex) 포켓몬스터 금 은 버전, 롤러코스터 타이쿤 등.

요즘은 예전만큼 잘 사용되지 않는 듯 하다. 어셈블리어를 읽고 코드의 작동 원리, 문제의 원인을 파악할 수 있는 정도면 충분한 듯.

[https://velog.io/@gkswh4860/어셈블리어를-배워야-하는-이유-증감-연산자-최적화의-진실](https://velog.io/@gkswh4860/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4%EB%A5%BC-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%B5%9C%EC%A0%81%ED%99%94%EC%9D%98-%EC%A7%84%EC%8B%A4)

# 2. 명령어의 구조

---

기계어나 어셈블리어를 이루는 하나하나가 명령어이다. 명령어는 **연산 코드**와 **오퍼랜드**로 구성되어 있다.

## 연산 코드와 오퍼랜드

---

push   rbp

add     eax,   edx

### 연산코드

---

push, add

명령어가 수행할 연산, 연산자

명령어에서 연산 코드가 담기는 영역을 연산코드 필드라고 한다.

**가장 기본적인 연산 코드 유형**

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

연산 코드의 종류와 생김새는 CPU마다 다르다.

### 오퍼랜드

---

rbp, edx

연산에 사용할 데이터 또는 그 데이터가 저장된 위치, 피연산자

명령어에서 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다.

명령어 안에 하나도 없을 수도 있고, 여러 개 있을 수 있다. 개수에 따라 불리는 이름이 다르다.

오퍼랜드가 0개인 경우 → 0-주소 명령어

오퍼랜드가 n(1~3)개인 경우 → n-주소 명령어

오퍼랜드 필드에는 데이터를 직접 명시하기 보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치(메모리 주소, 레지스터 이름)가 담기기 때문에 **주소 필드**라고도 불림.

> 왜 연산에 사용할 데이터 저장된 위치를 많이 담는가?
**명령어의 길이 때문이다.** 연산 코드를 제외하고 명령어 안에 오퍼랜드가 담길 수 있는 데이터의 크기는 한정되어 있으므로, 정보를 담은 다른 공간의 주소를 담아 호출하는 쪽이 더 많은 양의 데이터를 담을 수 있어 이득이다.
> 

### 주소 지정 방식

---

연산의 대상이 되는 데이터가 저장된 위치를 유효 주소(effective address)라고 한다. 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 **주소 지정 방식**이라고 한다.

대표적인 주소 지정 방식에는 5가지가 있다.

- 즉시 주소 지정 방식
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 표현할 수 있는 데이터 크기가 작음.
    - 찾는 과정이 없어서 빠름.

- 직접 주소 지정 방식
    - 유효 주소를 오퍼랜드 필드에 직접 명시

- 간접 주소 지정 방식
    - 유효 주소의 주소를 오퍼랜드 필드에 명시
    - 표현할 수 있는 유효 주소의 범위가 넓어짐.
    - 두 번의 메모리 접근이 필요해서 더 느림.

- 레지스터 주소 지정 방식
    - 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 명시
    - CPU 내부에 있는 레지스터에 접근하다 보니 메모리에 접근하는 앞서 말한 방식들보다 빠름.

- 레지스터 간접 주소 지정 방식
    - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시

[https://jeongminhee99.tistory.com/48](https://jeongminhee99.tistory.com/48)